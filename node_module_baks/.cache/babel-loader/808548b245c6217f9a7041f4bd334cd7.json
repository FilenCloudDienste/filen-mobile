{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport createCallbackMemoizer from '../utils/createCallbackMemoizer';\n/**\n * Higher-order component that manages lazy-loading for \"infinite\" data.\n * This component decorates a virtual component and just-in-time prefetches rows as a user scrolls.\n * It is intended as a convenience component; fork it if you'd like finer-grained control over data-loading.\n */\n\nvar InfiniteLoader = /*#__PURE__*/function (_React$PureComponent) {\n  _inherits(InfiniteLoader, _React$PureComponent);\n\n  function InfiniteLoader(props, context) {\n    var _this;\n\n    _classCallCheck(this, InfiniteLoader);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(InfiniteLoader).call(this, props, context));\n    _this._loadMoreRowsMemoizer = createCallbackMemoizer();\n    _this._onRowsRendered = _this._onRowsRendered.bind(_assertThisInitialized(_this));\n    _this._registerChild = _this._registerChild.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(InfiniteLoader, [{\n    key: \"resetLoadMoreRowsCache\",\n    value: function resetLoadMoreRowsCache(autoReload) {\n      this._loadMoreRowsMemoizer = createCallbackMemoizer();\n\n      if (autoReload) {\n        this._doStuff(this._lastRenderedStartIndex, this._lastRenderedStopIndex);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var children = this.props.children;\n      return children({\n        onRowsRendered: this._onRowsRendered,\n        registerChild: this._registerChild\n      });\n    }\n  }, {\n    key: \"_loadUnloadedRanges\",\n    value: function _loadUnloadedRanges(unloadedRanges) {\n      var _this2 = this;\n\n      var loadMoreRows = this.props.loadMoreRows;\n      unloadedRanges.forEach(function (unloadedRange) {\n        var promise = loadMoreRows(unloadedRange);\n\n        if (promise) {\n          promise.then(function () {\n            // Refresh the visible rows if any of them have just been loaded.\n            // Otherwise they will remain in their unloaded visual state.\n            if (isRangeVisible({\n              lastRenderedStartIndex: _this2._lastRenderedStartIndex,\n              lastRenderedStopIndex: _this2._lastRenderedStopIndex,\n              startIndex: unloadedRange.startIndex,\n              stopIndex: unloadedRange.stopIndex\n            })) {\n              if (_this2._registeredChild) {\n                forceUpdateReactVirtualizedComponent(_this2._registeredChild, _this2._lastRenderedStartIndex);\n              }\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: \"_onRowsRendered\",\n    value: function _onRowsRendered(_ref) {\n      var startIndex = _ref.startIndex,\n          stopIndex = _ref.stopIndex;\n      this._lastRenderedStartIndex = startIndex;\n      this._lastRenderedStopIndex = stopIndex;\n\n      this._doStuff(startIndex, stopIndex);\n    }\n  }, {\n    key: \"_doStuff\",\n    value: function _doStuff(startIndex, stopIndex) {\n      var _ref2,\n          _this3 = this;\n\n      var _this$props = this.props,\n          isRowLoaded = _this$props.isRowLoaded,\n          minimumBatchSize = _this$props.minimumBatchSize,\n          rowCount = _this$props.rowCount,\n          threshold = _this$props.threshold;\n      var unloadedRanges = scanForUnloadedRanges({\n        isRowLoaded: isRowLoaded,\n        minimumBatchSize: minimumBatchSize,\n        rowCount: rowCount,\n        startIndex: Math.max(0, startIndex - threshold),\n        stopIndex: Math.min(rowCount - 1, stopIndex + threshold)\n      }); // For memoize comparison\n\n      var squashedUnloadedRanges = (_ref2 = []).concat.apply(_ref2, _toConsumableArray(unloadedRanges.map(function (_ref3) {\n        var startIndex = _ref3.startIndex,\n            stopIndex = _ref3.stopIndex;\n        return [startIndex, stopIndex];\n      })));\n\n      this._loadMoreRowsMemoizer({\n        callback: function callback() {\n          _this3._loadUnloadedRanges(unloadedRanges);\n        },\n        indices: {\n          squashedUnloadedRanges: squashedUnloadedRanges\n        }\n      });\n    }\n  }, {\n    key: \"_registerChild\",\n    value: function _registerChild(registeredChild) {\n      this._registeredChild = registeredChild;\n    }\n  }]);\n\n  return InfiniteLoader;\n}(React.PureComponent);\n/**\n * Determines if the specified start/stop range is visible based on the most recently rendered range.\n */\n\n\n_defineProperty(InfiniteLoader, \"defaultProps\", {\n  minimumBatchSize: 10,\n  rowCount: 0,\n  threshold: 15\n});\n\nexport { InfiniteLoader as default };\nInfiniteLoader.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * Function responsible for rendering a virtualized component.\n   * This function should implement the following signature:\n   * ({ onRowsRendered, registerChild }) => PropTypes.element\n   *\n   * The specified :onRowsRendered function should be passed through to the child's :onRowsRendered property.\n   * The :registerChild callback should be set as the virtualized component's :ref.\n   */\n  children: PropTypes.func.isRequired,\n\n  /**\n   * Function responsible for tracking the loaded state of each row.\n   * It should implement the following signature: ({ index: number }): boolean\n   */\n  isRowLoaded: PropTypes.func.isRequired,\n\n  /**\n   * Callback to be invoked when more rows must be loaded.\n   * It should implement the following signature: ({ startIndex, stopIndex }): Promise\n   * The returned Promise should be resolved once row data has finished loading.\n   * It will be used to determine when to refresh the list with the newly-loaded data.\n   * This callback may be called multiple times in reaction to a single scroll event.\n   */\n  loadMoreRows: PropTypes.func.isRequired,\n\n  /**\n   * Minimum number of rows to be loaded at a time.\n   * This property can be used to batch requests to reduce HTTP requests.\n   */\n  minimumBatchSize: PropTypes.number.isRequired,\n\n  /**\n   * Number of rows in list; can be arbitrary high number if actual number is unknown.\n   */\n  rowCount: PropTypes.number.isRequired,\n\n  /**\n   * Threshold at which to pre-fetch data.\n   * A threshold X means that data will start loading when a user scrolls within X rows.\n   * This value defaults to 15.\n   */\n  threshold: PropTypes.number.isRequired\n} : {};\nexport function isRangeVisible(_ref4) {\n  var lastRenderedStartIndex = _ref4.lastRenderedStartIndex,\n      lastRenderedStopIndex = _ref4.lastRenderedStopIndex,\n      startIndex = _ref4.startIndex,\n      stopIndex = _ref4.stopIndex;\n  return !(startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex);\n}\n/**\n * Returns all of the ranges within a larger range that contain unloaded rows.\n */\n\nexport function scanForUnloadedRanges(_ref5) {\n  var isRowLoaded = _ref5.isRowLoaded,\n      minimumBatchSize = _ref5.minimumBatchSize,\n      rowCount = _ref5.rowCount,\n      startIndex = _ref5.startIndex,\n      stopIndex = _ref5.stopIndex;\n  var unloadedRanges = [];\n  var rangeStartIndex = null;\n  var rangeStopIndex = null;\n\n  for (var index = startIndex; index <= stopIndex; index++) {\n    var loaded = isRowLoaded({\n      index: index\n    });\n\n    if (!loaded) {\n      rangeStopIndex = index;\n\n      if (rangeStartIndex === null) {\n        rangeStartIndex = index;\n      }\n    } else if (rangeStopIndex !== null) {\n      unloadedRanges.push({\n        startIndex: rangeStartIndex,\n        stopIndex: rangeStopIndex\n      });\n      rangeStartIndex = rangeStopIndex = null;\n    }\n  } // If :rangeStopIndex is not null it means we haven't ran out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n\n\n  if (rangeStopIndex !== null) {\n    var potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), rowCount - 1);\n\n    for (var _index = rangeStopIndex + 1; _index <= potentialStopIndex; _index++) {\n      if (!isRowLoaded({\n        index: _index\n      })) {\n        rangeStopIndex = _index;\n      } else {\n        break;\n      }\n    }\n\n    unloadedRanges.push({\n      startIndex: rangeStartIndex,\n      stopIndex: rangeStopIndex\n    });\n  } // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n\n\n  if (unloadedRanges.length) {\n    var firstUnloadedRange = unloadedRanges[0];\n\n    while (firstUnloadedRange.stopIndex - firstUnloadedRange.startIndex + 1 < minimumBatchSize && firstUnloadedRange.startIndex > 0) {\n      var _index2 = firstUnloadedRange.startIndex - 1;\n\n      if (!isRowLoaded({\n        index: _index2\n      })) {\n        firstUnloadedRange.startIndex = _index2;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return unloadedRanges;\n}\n/**\n * Since RV components use shallowCompare we need to force a render (even though props haven't changed).\n * However InfiniteLoader may wrap a Grid or it may wrap a Table or List.\n * In the first case the built-in React forceUpdate() method is sufficient to force a re-render,\n * But in the latter cases we need to use the RV-specific forceUpdateGrid() method.\n * Else the inner Grid will not be re-rendered and visuals may be stale.\n *\n * Additionally, while a Grid is scrolling the cells can be cached,\n * So it's important to invalidate that cache by recalculating sizes\n * before forcing a rerender.\n */\n\nexport function forceUpdateReactVirtualizedComponent(component) {\n  var currentIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var recomputeSize = typeof component.recomputeGridSize === 'function' ? component.recomputeGridSize : component.recomputeRowHeights;\n\n  if (recomputeSize) {\n    recomputeSize.call(component, currentIndex);\n  } else {\n    component.forceUpdate();\n  }\n}","map":{"version":3,"sources":["/Users/jan/Documents/filen/app/node_modules/react-virtualized/dist/es/InfiniteLoader/InfiniteLoader.js"],"names":["_toConsumableArray","_classCallCheck","_createClass","_possibleConstructorReturn","_getPrototypeOf","_assertThisInitialized","_inherits","_defineProperty","React","PropTypes","createCallbackMemoizer","InfiniteLoader","_React$PureComponent","props","context","_this","call","_loadMoreRowsMemoizer","_onRowsRendered","bind","_registerChild","key","value","resetLoadMoreRowsCache","autoReload","_doStuff","_lastRenderedStartIndex","_lastRenderedStopIndex","render","children","onRowsRendered","registerChild","_loadUnloadedRanges","unloadedRanges","_this2","loadMoreRows","forEach","unloadedRange","promise","then","isRangeVisible","lastRenderedStartIndex","lastRenderedStopIndex","startIndex","stopIndex","_registeredChild","forceUpdateReactVirtualizedComponent","_ref","_ref2","_this3","_this$props","isRowLoaded","minimumBatchSize","rowCount","threshold","scanForUnloadedRanges","Math","max","min","squashedUnloadedRanges","concat","apply","map","_ref3","callback","indices","registeredChild","PureComponent","default","propTypes","process","env","NODE_ENV","func","isRequired","number","_ref4","_ref5","rangeStartIndex","rangeStopIndex","index","loaded","push","potentialStopIndex","_index","length","firstUnloadedRange","_index2","component","currentIndex","arguments","undefined","recomputeSize","recomputeGridSize","recomputeRowHeights","forceUpdate"],"mappings":"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","sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport createCallbackMemoizer from '../utils/createCallbackMemoizer';\n/**\n * Higher-order component that manages lazy-loading for \"infinite\" data.\n * This component decorates a virtual component and just-in-time prefetches rows as a user scrolls.\n * It is intended as a convenience component; fork it if you'd like finer-grained control over data-loading.\n */\n\nvar InfiniteLoader =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(InfiniteLoader, _React$PureComponent);\n\n  function InfiniteLoader(props, context) {\n    var _this;\n\n    _classCallCheck(this, InfiniteLoader);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(InfiniteLoader).call(this, props, context));\n    _this._loadMoreRowsMemoizer = createCallbackMemoizer();\n    _this._onRowsRendered = _this._onRowsRendered.bind(_assertThisInitialized(_this));\n    _this._registerChild = _this._registerChild.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(InfiniteLoader, [{\n    key: \"resetLoadMoreRowsCache\",\n    value: function resetLoadMoreRowsCache(autoReload) {\n      this._loadMoreRowsMemoizer = createCallbackMemoizer();\n\n      if (autoReload) {\n        this._doStuff(this._lastRenderedStartIndex, this._lastRenderedStopIndex);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var children = this.props.children;\n      return children({\n        onRowsRendered: this._onRowsRendered,\n        registerChild: this._registerChild\n      });\n    }\n  }, {\n    key: \"_loadUnloadedRanges\",\n    value: function _loadUnloadedRanges(unloadedRanges) {\n      var _this2 = this;\n\n      var loadMoreRows = this.props.loadMoreRows;\n      unloadedRanges.forEach(function (unloadedRange) {\n        var promise = loadMoreRows(unloadedRange);\n\n        if (promise) {\n          promise.then(function () {\n            // Refresh the visible rows if any of them have just been loaded.\n            // Otherwise they will remain in their unloaded visual state.\n            if (isRangeVisible({\n              lastRenderedStartIndex: _this2._lastRenderedStartIndex,\n              lastRenderedStopIndex: _this2._lastRenderedStopIndex,\n              startIndex: unloadedRange.startIndex,\n              stopIndex: unloadedRange.stopIndex\n            })) {\n              if (_this2._registeredChild) {\n                forceUpdateReactVirtualizedComponent(_this2._registeredChild, _this2._lastRenderedStartIndex);\n              }\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: \"_onRowsRendered\",\n    value: function _onRowsRendered(_ref) {\n      var startIndex = _ref.startIndex,\n          stopIndex = _ref.stopIndex;\n      this._lastRenderedStartIndex = startIndex;\n      this._lastRenderedStopIndex = stopIndex;\n\n      this._doStuff(startIndex, stopIndex);\n    }\n  }, {\n    key: \"_doStuff\",\n    value: function _doStuff(startIndex, stopIndex) {\n      var _ref2,\n          _this3 = this;\n\n      var _this$props = this.props,\n          isRowLoaded = _this$props.isRowLoaded,\n          minimumBatchSize = _this$props.minimumBatchSize,\n          rowCount = _this$props.rowCount,\n          threshold = _this$props.threshold;\n      var unloadedRanges = scanForUnloadedRanges({\n        isRowLoaded: isRowLoaded,\n        minimumBatchSize: minimumBatchSize,\n        rowCount: rowCount,\n        startIndex: Math.max(0, startIndex - threshold),\n        stopIndex: Math.min(rowCount - 1, stopIndex + threshold)\n      }); // For memoize comparison\n\n      var squashedUnloadedRanges = (_ref2 = []).concat.apply(_ref2, _toConsumableArray(unloadedRanges.map(function (_ref3) {\n        var startIndex = _ref3.startIndex,\n            stopIndex = _ref3.stopIndex;\n        return [startIndex, stopIndex];\n      })));\n\n      this._loadMoreRowsMemoizer({\n        callback: function callback() {\n          _this3._loadUnloadedRanges(unloadedRanges);\n        },\n        indices: {\n          squashedUnloadedRanges: squashedUnloadedRanges\n        }\n      });\n    }\n  }, {\n    key: \"_registerChild\",\n    value: function _registerChild(registeredChild) {\n      this._registeredChild = registeredChild;\n    }\n  }]);\n\n  return InfiniteLoader;\n}(React.PureComponent);\n/**\n * Determines if the specified start/stop range is visible based on the most recently rendered range.\n */\n\n\n_defineProperty(InfiniteLoader, \"defaultProps\", {\n  minimumBatchSize: 10,\n  rowCount: 0,\n  threshold: 15\n});\n\nexport { InfiniteLoader as default };\nInfiniteLoader.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * Function responsible for rendering a virtualized component.\n   * This function should implement the following signature:\n   * ({ onRowsRendered, registerChild }) => PropTypes.element\n   *\n   * The specified :onRowsRendered function should be passed through to the child's :onRowsRendered property.\n   * The :registerChild callback should be set as the virtualized component's :ref.\n   */\n  children: PropTypes.func.isRequired,\n\n  /**\n   * Function responsible for tracking the loaded state of each row.\n   * It should implement the following signature: ({ index: number }): boolean\n   */\n  isRowLoaded: PropTypes.func.isRequired,\n\n  /**\n   * Callback to be invoked when more rows must be loaded.\n   * It should implement the following signature: ({ startIndex, stopIndex }): Promise\n   * The returned Promise should be resolved once row data has finished loading.\n   * It will be used to determine when to refresh the list with the newly-loaded data.\n   * This callback may be called multiple times in reaction to a single scroll event.\n   */\n  loadMoreRows: PropTypes.func.isRequired,\n\n  /**\n   * Minimum number of rows to be loaded at a time.\n   * This property can be used to batch requests to reduce HTTP requests.\n   */\n  minimumBatchSize: PropTypes.number.isRequired,\n\n  /**\n   * Number of rows in list; can be arbitrary high number if actual number is unknown.\n   */\n  rowCount: PropTypes.number.isRequired,\n\n  /**\n   * Threshold at which to pre-fetch data.\n   * A threshold X means that data will start loading when a user scrolls within X rows.\n   * This value defaults to 15.\n   */\n  threshold: PropTypes.number.isRequired\n} : {};\nexport function isRangeVisible(_ref4) {\n  var lastRenderedStartIndex = _ref4.lastRenderedStartIndex,\n      lastRenderedStopIndex = _ref4.lastRenderedStopIndex,\n      startIndex = _ref4.startIndex,\n      stopIndex = _ref4.stopIndex;\n  return !(startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex);\n}\n/**\n * Returns all of the ranges within a larger range that contain unloaded rows.\n */\n\nexport function scanForUnloadedRanges(_ref5) {\n  var isRowLoaded = _ref5.isRowLoaded,\n      minimumBatchSize = _ref5.minimumBatchSize,\n      rowCount = _ref5.rowCount,\n      startIndex = _ref5.startIndex,\n      stopIndex = _ref5.stopIndex;\n  var unloadedRanges = [];\n  var rangeStartIndex = null;\n  var rangeStopIndex = null;\n\n  for (var index = startIndex; index <= stopIndex; index++) {\n    var loaded = isRowLoaded({\n      index: index\n    });\n\n    if (!loaded) {\n      rangeStopIndex = index;\n\n      if (rangeStartIndex === null) {\n        rangeStartIndex = index;\n      }\n    } else if (rangeStopIndex !== null) {\n      unloadedRanges.push({\n        startIndex: rangeStartIndex,\n        stopIndex: rangeStopIndex\n      });\n      rangeStartIndex = rangeStopIndex = null;\n    }\n  } // If :rangeStopIndex is not null it means we haven't ran out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n\n\n  if (rangeStopIndex !== null) {\n    var potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), rowCount - 1);\n\n    for (var _index = rangeStopIndex + 1; _index <= potentialStopIndex; _index++) {\n      if (!isRowLoaded({\n        index: _index\n      })) {\n        rangeStopIndex = _index;\n      } else {\n        break;\n      }\n    }\n\n    unloadedRanges.push({\n      startIndex: rangeStartIndex,\n      stopIndex: rangeStopIndex\n    });\n  } // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n\n\n  if (unloadedRanges.length) {\n    var firstUnloadedRange = unloadedRanges[0];\n\n    while (firstUnloadedRange.stopIndex - firstUnloadedRange.startIndex + 1 < minimumBatchSize && firstUnloadedRange.startIndex > 0) {\n      var _index2 = firstUnloadedRange.startIndex - 1;\n\n      if (!isRowLoaded({\n        index: _index2\n      })) {\n        firstUnloadedRange.startIndex = _index2;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return unloadedRanges;\n}\n/**\n * Since RV components use shallowCompare we need to force a render (even though props haven't changed).\n * However InfiniteLoader may wrap a Grid or it may wrap a Table or List.\n * In the first case the built-in React forceUpdate() method is sufficient to force a re-render,\n * But in the latter cases we need to use the RV-specific forceUpdateGrid() method.\n * Else the inner Grid will not be re-rendered and visuals may be stale.\n *\n * Additionally, while a Grid is scrolling the cells can be cached,\n * So it's important to invalidate that cache by recalculating sizes\n * before forcing a rerender.\n */\n\nexport function forceUpdateReactVirtualizedComponent(component) {\n  var currentIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var recomputeSize = typeof component.recomputeGridSize === 'function' ? component.recomputeGridSize : component.recomputeRowHeights;\n\n  if (recomputeSize) {\n    recomputeSize.call(component, currentIndex);\n  } else {\n    component.forceUpdate();\n  }\n}"]},"metadata":{},"sourceType":"module"}