{"ast":null,"code":"/**\n * Helper method that determines when to recalculate row or column metadata.\n */\nexport default function calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {\n  var cellCount = _ref.cellCount,\n      cellSize = _ref.cellSize,\n      computeMetadataCallback = _ref.computeMetadataCallback,\n      computeMetadataCallbackProps = _ref.computeMetadataCallbackProps,\n      nextCellsCount = _ref.nextCellsCount,\n      nextCellSize = _ref.nextCellSize,\n      nextScrollToIndex = _ref.nextScrollToIndex,\n      scrollToIndex = _ref.scrollToIndex,\n      updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex; // Don't compare cell sizes if they are functions because inline functions would cause infinite loops.\n  // In that event users should use the manual recompute methods to inform of changes.\n\n  if (cellCount !== nextCellsCount || (typeof cellSize === 'number' || typeof nextCellSize === 'number') && cellSize !== nextCellSize) {\n    computeMetadataCallback(computeMetadataCallbackProps); // Updated cell metadata may have hidden the previous scrolled-to item.\n    // In this case we should also update the scrollTop to ensure it stays visible.\n\n    if (scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex) {\n      updateScrollOffsetForScrollToIndex();\n    }\n  }\n}","map":{"version":3,"sources":["/Users/jan/Documents/filen/app/node_modules/react-virtualized/dist/es/Grid/utils/calculateSizeAndPositionDataAndUpdateScrollOffset.js"],"names":["calculateSizeAndPositionDataAndUpdateScrollOffset","_ref","cellCount","cellSize","computeMetadataCallback","computeMetadataCallbackProps","nextCellsCount","nextCellSize","nextScrollToIndex","scrollToIndex","updateScrollOffsetForScrollToIndex"],"mappings":"AAAA;AACA;AACA;AACA,eAAe,SAASA,iDAAT,CAA2DC,IAA3D,EAAiE;AAC9E,MAAIC,SAAS,GAAGD,IAAI,CAACC,SAArB;AAAA,MACIC,QAAQ,GAAGF,IAAI,CAACE,QADpB;AAAA,MAEIC,uBAAuB,GAAGH,IAAI,CAACG,uBAFnC;AAAA,MAGIC,4BAA4B,GAAGJ,IAAI,CAACI,4BAHxC;AAAA,MAIIC,cAAc,GAAGL,IAAI,CAACK,cAJ1B;AAAA,MAKIC,YAAY,GAAGN,IAAI,CAACM,YALxB;AAAA,MAMIC,iBAAiB,GAAGP,IAAI,CAACO,iBAN7B;AAAA,MAOIC,aAAa,GAAGR,IAAI,CAACQ,aAPzB;AAAA,MAQIC,kCAAkC,GAAGT,IAAI,CAACS,kCAR9C,CAD8E,CAW9E;AACA;;AACA,MAAIR,SAAS,KAAKI,cAAd,IAAgC,CAAC,OAAOH,QAAP,KAAoB,QAApB,IAAgC,OAAOI,YAAP,KAAwB,QAAzD,KAAsEJ,QAAQ,KAAKI,YAAvH,EAAqI;AACnIH,IAAAA,uBAAuB,CAACC,4BAAD,CAAvB,CADmI,CAC5E;AACvD;;AAEA,QAAII,aAAa,IAAI,CAAjB,IAAsBA,aAAa,KAAKD,iBAA5C,EAA+D;AAC7DE,MAAAA,kCAAkC;AACnC;AACF;AACF","sourcesContent":["/**\n * Helper method that determines when to recalculate row or column metadata.\n */\nexport default function calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {\n  var cellCount = _ref.cellCount,\n      cellSize = _ref.cellSize,\n      computeMetadataCallback = _ref.computeMetadataCallback,\n      computeMetadataCallbackProps = _ref.computeMetadataCallbackProps,\n      nextCellsCount = _ref.nextCellsCount,\n      nextCellSize = _ref.nextCellSize,\n      nextScrollToIndex = _ref.nextScrollToIndex,\n      scrollToIndex = _ref.scrollToIndex,\n      updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex;\n\n  // Don't compare cell sizes if they are functions because inline functions would cause infinite loops.\n  // In that event users should use the manual recompute methods to inform of changes.\n  if (cellCount !== nextCellsCount || (typeof cellSize === 'number' || typeof nextCellSize === 'number') && cellSize !== nextCellSize) {\n    computeMetadataCallback(computeMetadataCallbackProps); // Updated cell metadata may have hidden the previous scrolled-to item.\n    // In this case we should also update the scrollTop to ensure it stays visible.\n\n    if (scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex) {\n      updateScrollOffsetForScrollToIndex();\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}