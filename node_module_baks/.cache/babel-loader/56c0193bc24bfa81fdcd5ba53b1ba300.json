{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport createIntervalTree from '../vendor/intervalTree'; // Position cache requirements:\n//   O(log(n)) lookup of cells to render for a given viewport size\n//   O(1) lookup of shortest measured column (so we know when to enter phase 1)\n\nvar PositionCache = /*#__PURE__*/function () {\n  function PositionCache() {\n    _classCallCheck(this, PositionCache);\n\n    _defineProperty(this, \"_columnSizeMap\", {});\n\n    _defineProperty(this, \"_intervalTree\", createIntervalTree());\n\n    _defineProperty(this, \"_leftMap\", {});\n  }\n\n  _createClass(PositionCache, [{\n    key: \"estimateTotalHeight\",\n    value: function estimateTotalHeight(cellCount, columnCount, defaultCellHeight) {\n      var unmeasuredCellCount = cellCount - this.count;\n      return this.tallestColumnSize + Math.ceil(unmeasuredCellCount / columnCount) * defaultCellHeight;\n    } // Render all cells visible within the viewport range defined.\n\n  }, {\n    key: \"range\",\n    value: function range(scrollTop, clientHeight, renderCallback) {\n      var _this = this;\n\n      this._intervalTree.queryInterval(scrollTop, scrollTop + clientHeight, function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 3),\n            top = _ref2[0],\n            _ = _ref2[1],\n            index = _ref2[2];\n\n        return renderCallback(index, _this._leftMap[index], top);\n      });\n    }\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(index, left, top, height) {\n      this._intervalTree.insert([top, top + height, index]);\n\n      this._leftMap[index] = left;\n      var columnSizeMap = this._columnSizeMap;\n      var columnHeight = columnSizeMap[left];\n\n      if (columnHeight === undefined) {\n        columnSizeMap[left] = top + height;\n      } else {\n        columnSizeMap[left] = Math.max(columnHeight, top + height);\n      }\n    }\n  }, {\n    key: \"count\",\n    get: function get() {\n      return this._intervalTree.count;\n    }\n  }, {\n    key: \"shortestColumnSize\",\n    get: function get() {\n      var columnSizeMap = this._columnSizeMap;\n      var size = 0;\n\n      for (var i in columnSizeMap) {\n        var height = columnSizeMap[i];\n        size = size === 0 ? height : Math.min(size, height);\n      }\n\n      return size;\n    }\n  }, {\n    key: \"tallestColumnSize\",\n    get: function get() {\n      var columnSizeMap = this._columnSizeMap;\n      var size = 0;\n\n      for (var i in columnSizeMap) {\n        var height = columnSizeMap[i];\n        size = Math.max(size, height);\n      }\n\n      return size;\n    }\n  }]);\n\n  return PositionCache;\n}();\n\nexport { PositionCache as default };","map":{"version":3,"sources":["/Users/jan/Documents/filen/app/node_modules/react-virtualized/dist/es/Masonry/PositionCache.js"],"names":["_slicedToArray","_classCallCheck","_createClass","_defineProperty","createIntervalTree","PositionCache","key","value","estimateTotalHeight","cellCount","columnCount","defaultCellHeight","unmeasuredCellCount","count","tallestColumnSize","Math","ceil","range","scrollTop","clientHeight","renderCallback","_this","_intervalTree","queryInterval","_ref","_ref2","top","_","index","_leftMap","setPosition","left","height","insert","columnSizeMap","_columnSizeMap","columnHeight","undefined","max","get","size","i","min","default"],"mappings":"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","sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport createIntervalTree from '../vendor/intervalTree';\n\n// Position cache requirements:\n//   O(log(n)) lookup of cells to render for a given viewport size\n//   O(1) lookup of shortest measured column (so we know when to enter phase 1)\nvar PositionCache =\n/*#__PURE__*/\nfunction () {\n  function PositionCache() {\n    _classCallCheck(this, PositionCache);\n\n    _defineProperty(this, \"_columnSizeMap\", {});\n\n    _defineProperty(this, \"_intervalTree\", createIntervalTree());\n\n    _defineProperty(this, \"_leftMap\", {});\n  }\n\n  _createClass(PositionCache, [{\n    key: \"estimateTotalHeight\",\n    value: function estimateTotalHeight(cellCount, columnCount, defaultCellHeight) {\n      var unmeasuredCellCount = cellCount - this.count;\n      return this.tallestColumnSize + Math.ceil(unmeasuredCellCount / columnCount) * defaultCellHeight;\n    } // Render all cells visible within the viewport range defined.\n\n  }, {\n    key: \"range\",\n    value: function range(scrollTop, clientHeight, renderCallback) {\n      var _this = this;\n\n      this._intervalTree.queryInterval(scrollTop, scrollTop + clientHeight, function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 3),\n            top = _ref2[0],\n            _ = _ref2[1],\n            index = _ref2[2];\n\n        return renderCallback(index, _this._leftMap[index], top);\n      });\n    }\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(index, left, top, height) {\n      this._intervalTree.insert([top, top + height, index]);\n\n      this._leftMap[index] = left;\n      var columnSizeMap = this._columnSizeMap;\n      var columnHeight = columnSizeMap[left];\n\n      if (columnHeight === undefined) {\n        columnSizeMap[left] = top + height;\n      } else {\n        columnSizeMap[left] = Math.max(columnHeight, top + height);\n      }\n    }\n  }, {\n    key: \"count\",\n    get: function get() {\n      return this._intervalTree.count;\n    }\n  }, {\n    key: \"shortestColumnSize\",\n    get: function get() {\n      var columnSizeMap = this._columnSizeMap;\n      var size = 0;\n\n      for (var i in columnSizeMap) {\n        var height = columnSizeMap[i];\n        size = size === 0 ? height : Math.min(size, height);\n      }\n\n      return size;\n    }\n  }, {\n    key: \"tallestColumnSize\",\n    get: function get() {\n      var columnSizeMap = this._columnSizeMap;\n      var size = 0;\n\n      for (var i in columnSizeMap) {\n        var height = columnSizeMap[i];\n        size = Math.max(size, height);\n      }\n\n      return size;\n    }\n  }]);\n\n  return PositionCache;\n}();\n\nexport { PositionCache as default };"]},"metadata":{},"sourceType":"module"}