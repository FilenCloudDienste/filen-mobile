{"ast":null,"code":"/**\n * Gets the dimensions of the element, accounting for API differences between\n * `window` and other DOM elements.\n */\n// TODO Move this into WindowScroller and import from there\nvar isWindow = function isWindow(element) {\n  return element === window;\n};\n\nvar getBoundingBox = function getBoundingBox(element) {\n  return element.getBoundingClientRect();\n};\n\nexport function getDimensions(scrollElement, props) {\n  if (!scrollElement) {\n    return {\n      height: props.serverHeight,\n      width: props.serverWidth\n    };\n  } else if (isWindow(scrollElement)) {\n    var _window = window,\n        innerHeight = _window.innerHeight,\n        innerWidth = _window.innerWidth;\n    return {\n      height: typeof innerHeight === 'number' ? innerHeight : 0,\n      width: typeof innerWidth === 'number' ? innerWidth : 0\n    };\n  } else {\n    return getBoundingBox(scrollElement);\n  }\n}\n/**\n * Gets the vertical and horizontal position of an element within its scroll container.\n * Elements that have been “scrolled past” return negative values.\n * Handles edge-case where a user is navigating back (history) from an already-scrolled page.\n * In this case the body’s top or left position will be a negative number and this element’s top or left will be increased (by that amount).\n */\n\nexport function getPositionOffset(element, container) {\n  if (isWindow(container) && document.documentElement) {\n    var containerElement = document.documentElement;\n    var elementRect = getBoundingBox(element);\n    var containerRect = getBoundingBox(containerElement);\n    return {\n      top: elementRect.top - containerRect.top,\n      left: elementRect.left - containerRect.left\n    };\n  } else {\n    var scrollOffset = getScrollOffset(container);\n\n    var _elementRect = getBoundingBox(element);\n\n    var _containerRect = getBoundingBox(container);\n\n    return {\n      top: _elementRect.top + scrollOffset.top - _containerRect.top,\n      left: _elementRect.left + scrollOffset.left - _containerRect.left\n    };\n  }\n}\n/**\n * Gets the vertical and horizontal scroll amount of the element, accounting for IE compatibility\n * and API differences between `window` and other DOM elements.\n */\n\nexport function getScrollOffset(element) {\n  if (isWindow(element) && document.documentElement) {\n    return {\n      top: 'scrollY' in window ? window.scrollY : document.documentElement.scrollTop,\n      left: 'scrollX' in window ? window.scrollX : document.documentElement.scrollLeft\n    };\n  } else {\n    return {\n      top: element.scrollTop,\n      left: element.scrollLeft\n    };\n  }\n}","map":{"version":3,"sources":["/Users/jan/Documents/filen/app/node_modules/react-virtualized/dist/es/WindowScroller/utils/dimensions.js"],"names":["isWindow","element","window","getBoundingBox","getBoundingClientRect","getDimensions","scrollElement","props","height","serverHeight","width","serverWidth","_window","innerHeight","innerWidth","getPositionOffset","container","document","documentElement","containerElement","elementRect","containerRect","top","left","scrollOffset","getScrollOffset","_elementRect","_containerRect","scrollY","scrollTop","scrollX","scrollLeft"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,IAAIA,QAAQ,GAAG,SAASA,QAAT,CAAkBC,OAAlB,EAA2B;AACxC,SAAOA,OAAO,KAAKC,MAAnB;AACD,CAFD;;AAIA,IAAIC,cAAc,GAAG,SAASA,cAAT,CAAwBF,OAAxB,EAAiC;AACpD,SAAOA,OAAO,CAACG,qBAAR,EAAP;AACD,CAFD;;AAIA,OAAO,SAASC,aAAT,CAAuBC,aAAvB,EAAsCC,KAAtC,EAA6C;AAClD,MAAI,CAACD,aAAL,EAAoB;AAClB,WAAO;AACLE,MAAAA,MAAM,EAAED,KAAK,CAACE,YADT;AAELC,MAAAA,KAAK,EAAEH,KAAK,CAACI;AAFR,KAAP;AAID,GALD,MAKO,IAAIX,QAAQ,CAACM,aAAD,CAAZ,EAA6B;AAClC,QAAIM,OAAO,GAAGV,MAAd;AAAA,QACIW,WAAW,GAAGD,OAAO,CAACC,WAD1B;AAAA,QAEIC,UAAU,GAAGF,OAAO,CAACE,UAFzB;AAGA,WAAO;AACLN,MAAAA,MAAM,EAAE,OAAOK,WAAP,KAAuB,QAAvB,GAAkCA,WAAlC,GAAgD,CADnD;AAELH,MAAAA,KAAK,EAAE,OAAOI,UAAP,KAAsB,QAAtB,GAAiCA,UAAjC,GAA8C;AAFhD,KAAP;AAID,GARM,MAQA;AACL,WAAOX,cAAc,CAACG,aAAD,CAArB;AACD;AACF;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASS,iBAAT,CAA2Bd,OAA3B,EAAoCe,SAApC,EAA+C;AACpD,MAAIhB,QAAQ,CAACgB,SAAD,CAAR,IAAuBC,QAAQ,CAACC,eAApC,EAAqD;AACnD,QAAIC,gBAAgB,GAAGF,QAAQ,CAACC,eAAhC;AACA,QAAIE,WAAW,GAAGjB,cAAc,CAACF,OAAD,CAAhC;AACA,QAAIoB,aAAa,GAAGlB,cAAc,CAACgB,gBAAD,CAAlC;AACA,WAAO;AACLG,MAAAA,GAAG,EAAEF,WAAW,CAACE,GAAZ,GAAkBD,aAAa,CAACC,GADhC;AAELC,MAAAA,IAAI,EAAEH,WAAW,CAACG,IAAZ,GAAmBF,aAAa,CAACE;AAFlC,KAAP;AAID,GARD,MAQO;AACL,QAAIC,YAAY,GAAGC,eAAe,CAACT,SAAD,CAAlC;;AAEA,QAAIU,YAAY,GAAGvB,cAAc,CAACF,OAAD,CAAjC;;AAEA,QAAI0B,cAAc,GAAGxB,cAAc,CAACa,SAAD,CAAnC;;AAEA,WAAO;AACLM,MAAAA,GAAG,EAAEI,YAAY,CAACJ,GAAb,GAAmBE,YAAY,CAACF,GAAhC,GAAsCK,cAAc,CAACL,GADrD;AAELC,MAAAA,IAAI,EAAEG,YAAY,CAACH,IAAb,GAAoBC,YAAY,CAACD,IAAjC,GAAwCI,cAAc,CAACJ;AAFxD,KAAP;AAID;AACF;AACD;AACA;AACA;AACA;;AAEA,OAAO,SAASE,eAAT,CAAyBxB,OAAzB,EAAkC;AACvC,MAAID,QAAQ,CAACC,OAAD,CAAR,IAAqBgB,QAAQ,CAACC,eAAlC,EAAmD;AACjD,WAAO;AACLI,MAAAA,GAAG,EAAE,aAAapB,MAAb,GAAsBA,MAAM,CAAC0B,OAA7B,GAAuCX,QAAQ,CAACC,eAAT,CAAyBW,SADhE;AAELN,MAAAA,IAAI,EAAE,aAAarB,MAAb,GAAsBA,MAAM,CAAC4B,OAA7B,GAAuCb,QAAQ,CAACC,eAAT,CAAyBa;AAFjE,KAAP;AAID,GALD,MAKO;AACL,WAAO;AACLT,MAAAA,GAAG,EAAErB,OAAO,CAAC4B,SADR;AAELN,MAAAA,IAAI,EAAEtB,OAAO,CAAC8B;AAFT,KAAP;AAID;AACF","sourcesContent":["/**\n * Gets the dimensions of the element, accounting for API differences between\n * `window` and other DOM elements.\n */\n// TODO Move this into WindowScroller and import from there\nvar isWindow = function isWindow(element) {\n  return element === window;\n};\n\nvar getBoundingBox = function getBoundingBox(element) {\n  return element.getBoundingClientRect();\n};\n\nexport function getDimensions(scrollElement, props) {\n  if (!scrollElement) {\n    return {\n      height: props.serverHeight,\n      width: props.serverWidth\n    };\n  } else if (isWindow(scrollElement)) {\n    var _window = window,\n        innerHeight = _window.innerHeight,\n        innerWidth = _window.innerWidth;\n    return {\n      height: typeof innerHeight === 'number' ? innerHeight : 0,\n      width: typeof innerWidth === 'number' ? innerWidth : 0\n    };\n  } else {\n    return getBoundingBox(scrollElement);\n  }\n}\n/**\n * Gets the vertical and horizontal position of an element within its scroll container.\n * Elements that have been “scrolled past” return negative values.\n * Handles edge-case where a user is navigating back (history) from an already-scrolled page.\n * In this case the body’s top or left position will be a negative number and this element’s top or left will be increased (by that amount).\n */\n\nexport function getPositionOffset(element, container) {\n  if (isWindow(container) && document.documentElement) {\n    var containerElement = document.documentElement;\n    var elementRect = getBoundingBox(element);\n    var containerRect = getBoundingBox(containerElement);\n    return {\n      top: elementRect.top - containerRect.top,\n      left: elementRect.left - containerRect.left\n    };\n  } else {\n    var scrollOffset = getScrollOffset(container);\n\n    var _elementRect = getBoundingBox(element);\n\n    var _containerRect = getBoundingBox(container);\n\n    return {\n      top: _elementRect.top + scrollOffset.top - _containerRect.top,\n      left: _elementRect.left + scrollOffset.left - _containerRect.left\n    };\n  }\n}\n/**\n * Gets the vertical and horizontal scroll amount of the element, accounting for IE compatibility\n * and API differences between `window` and other DOM elements.\n */\n\nexport function getScrollOffset(element) {\n  if (isWindow(element) && document.documentElement) {\n    return {\n      top: 'scrollY' in window ? window.scrollY : document.documentElement.scrollTop,\n      left: 'scrollX' in window ? window.scrollX : document.documentElement.scrollLeft\n    };\n  } else {\n    return {\n      top: element.scrollTop,\n      left: element.scrollLeft\n    };\n  }\n}"]},"metadata":{},"sourceType":"module"}