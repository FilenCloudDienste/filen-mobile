{"ast":null,"code":"'use strict';\n\n(function (global) {\n  // minimal symbol polyfill for IE11 and others\n  if (typeof Symbol !== 'function') {\n    var Symbol = function Symbol(name) {\n      return name;\n    };\n\n    Symbol.nonNative = true;\n  }\n\n  var STATE_PLAINTEXT = Symbol('plaintext');\n  var STATE_HTML = Symbol('html');\n  var STATE_COMMENT = Symbol('comment');\n  var ALLOWED_TAGS_REGEX = /<(\\w*)>/g;\n  var NORMALIZE_TAG_REGEX = /<\\/?([^\\s\\/>]+)/;\n\n  function striptags(html, allowable_tags, tag_replacement) {\n    html = html || '';\n    allowable_tags = allowable_tags || [];\n    tag_replacement = tag_replacement || '';\n    var context = init_context(allowable_tags, tag_replacement);\n    return striptags_internal(html, context);\n  }\n\n  function init_striptags_stream(allowable_tags, tag_replacement) {\n    allowable_tags = allowable_tags || [];\n    tag_replacement = tag_replacement || '';\n    var context = init_context(allowable_tags, tag_replacement);\n    return function striptags_stream(html) {\n      return striptags_internal(html || '', context);\n    };\n  }\n\n  striptags.init_streaming_mode = init_striptags_stream;\n\n  function init_context(allowable_tags, tag_replacement) {\n    allowable_tags = parse_allowable_tags(allowable_tags);\n    return {\n      allowable_tags: allowable_tags,\n      tag_replacement: tag_replacement,\n      state: STATE_PLAINTEXT,\n      tag_buffer: '',\n      depth: 0,\n      in_quote_char: ''\n    };\n  }\n\n  function striptags_internal(html, context) {\n    var allowable_tags = context.allowable_tags;\n    var tag_replacement = context.tag_replacement;\n    var state = context.state;\n    var tag_buffer = context.tag_buffer;\n    var depth = context.depth;\n    var in_quote_char = context.in_quote_char;\n    var output = '';\n\n    for (var idx = 0, length = html.length; idx < length; idx++) {\n      var char = html[idx];\n\n      if (state === STATE_PLAINTEXT) {\n        switch (char) {\n          case '<':\n            state = STATE_HTML;\n            tag_buffer += char;\n            break;\n\n          default:\n            output += char;\n            break;\n        }\n      } else if (state === STATE_HTML) {\n        switch (char) {\n          case '<':\n            // ignore '<' if inside a quote\n            if (in_quote_char) {\n              break;\n            } // we're seeing a nested '<'\n\n\n            depth++;\n            break;\n\n          case '>':\n            // ignore '>' if inside a quote\n            if (in_quote_char) {\n              break;\n            } // something like this is happening: '<<>>'\n\n\n            if (depth) {\n              depth--;\n              break;\n            } // this is closing the tag in tag_buffer\n\n\n            in_quote_char = '';\n            state = STATE_PLAINTEXT;\n            tag_buffer += '>';\n\n            if (allowable_tags.has(normalize_tag(tag_buffer))) {\n              output += tag_buffer;\n            } else {\n              output += tag_replacement;\n            }\n\n            tag_buffer = '';\n            break;\n\n          case '\"':\n          case '\\'':\n            // catch both single and double quotes\n            if (char === in_quote_char) {\n              in_quote_char = '';\n            } else {\n              in_quote_char = in_quote_char || char;\n            }\n\n            tag_buffer += char;\n            break;\n\n          case '-':\n            if (tag_buffer === '<!-') {\n              state = STATE_COMMENT;\n            }\n\n            tag_buffer += char;\n            break;\n\n          case ' ':\n          case '\\n':\n            if (tag_buffer === '<') {\n              state = STATE_PLAINTEXT;\n              output += '< ';\n              tag_buffer = '';\n              break;\n            }\n\n            tag_buffer += char;\n            break;\n\n          default:\n            tag_buffer += char;\n            break;\n        }\n      } else if (state === STATE_COMMENT) {\n        switch (char) {\n          case '>':\n            if (tag_buffer.slice(-2) == '--') {\n              // close the comment\n              state = STATE_PLAINTEXT;\n            }\n\n            tag_buffer = '';\n            break;\n\n          default:\n            tag_buffer += char;\n            break;\n        }\n      }\n    } // save the context for future iterations\n\n\n    context.state = state;\n    context.tag_buffer = tag_buffer;\n    context.depth = depth;\n    context.in_quote_char = in_quote_char;\n    return output;\n  }\n\n  function parse_allowable_tags(allowable_tags) {\n    var tag_set = new Set();\n\n    if (typeof allowable_tags === 'string') {\n      var match;\n\n      while (match = ALLOWED_TAGS_REGEX.exec(allowable_tags)) {\n        tag_set.add(match[1]);\n      }\n    } else if (!Symbol.nonNative && typeof allowable_tags[Symbol.iterator] === 'function') {\n      tag_set = new Set(allowable_tags);\n    } else if (typeof allowable_tags.forEach === 'function') {\n      // IE11 compatible\n      allowable_tags.forEach(tag_set.add, tag_set);\n    }\n\n    return tag_set;\n  }\n\n  function normalize_tag(tag_buffer) {\n    var match = NORMALIZE_TAG_REGEX.exec(tag_buffer);\n    return match ? match[1].toLowerCase() : null;\n  }\n\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(function module_factory() {\n      return striptags;\n    });\n  } else if (typeof module === 'object' && module.exports) {\n    // Node\n    module.exports = striptags;\n  } else {\n    // Browser\n    global.striptags = striptags;\n  }\n})(this);","map":{"version":3,"sources":["/Users/jan/Documents/filen/app/node_modules/striptags/src/striptags.js"],"names":["global","Symbol","name","nonNative","STATE_PLAINTEXT","STATE_HTML","STATE_COMMENT","ALLOWED_TAGS_REGEX","NORMALIZE_TAG_REGEX","striptags","html","allowable_tags","tag_replacement","context","init_context","striptags_internal","init_striptags_stream","striptags_stream","init_streaming_mode","parse_allowable_tags","state","tag_buffer","depth","in_quote_char","output","idx","length","char","has","normalize_tag","slice","tag_set","Set","match","exec","add","iterator","forEach","toLowerCase","define","amd","module_factory","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n(function (global) {\n\n    // minimal symbol polyfill for IE11 and others\n    if (typeof Symbol !== 'function') {\n        var Symbol = function(name) {\n            return name;\n        }\n\n        Symbol.nonNative = true;\n    }\n\n    const STATE_PLAINTEXT = Symbol('plaintext');\n    const STATE_HTML      = Symbol('html');\n    const STATE_COMMENT   = Symbol('comment');\n\n    const ALLOWED_TAGS_REGEX  = /<(\\w*)>/g;\n    const NORMALIZE_TAG_REGEX = /<\\/?([^\\s\\/>]+)/;\n\n    function striptags(html, allowable_tags, tag_replacement) {\n        html            = html || '';\n        allowable_tags  = allowable_tags || [];\n        tag_replacement = tag_replacement || '';\n\n        let context = init_context(allowable_tags, tag_replacement);\n\n        return striptags_internal(html, context);\n    }\n\n    function init_striptags_stream(allowable_tags, tag_replacement) {\n        allowable_tags  = allowable_tags || [];\n        tag_replacement = tag_replacement || '';\n\n        let context = init_context(allowable_tags, tag_replacement);\n\n        return function striptags_stream(html) {\n            return striptags_internal(html || '', context);\n        };\n    }\n\n    striptags.init_streaming_mode = init_striptags_stream;\n\n    function init_context(allowable_tags, tag_replacement) {\n        allowable_tags = parse_allowable_tags(allowable_tags);\n\n        return {\n            allowable_tags : allowable_tags,\n            tag_replacement: tag_replacement,\n\n            state         : STATE_PLAINTEXT,\n            tag_buffer    : '',\n            depth         : 0,\n            in_quote_char : ''\n        };\n    }\n\n    function striptags_internal(html, context) {\n        let allowable_tags  = context.allowable_tags;\n        let tag_replacement = context.tag_replacement;\n\n        let state         = context.state;\n        let tag_buffer    = context.tag_buffer;\n        let depth         = context.depth;\n        let in_quote_char = context.in_quote_char;\n        let output        = '';\n\n        for (let idx = 0, length = html.length; idx < length; idx++) {\n            let char = html[idx];\n\n            if (state === STATE_PLAINTEXT) {\n                switch (char) {\n                    case '<':\n                        state       = STATE_HTML;\n                        tag_buffer += char;\n                        break;\n\n                    default:\n                        output += char;\n                        break;\n                }\n            }\n\n            else if (state === STATE_HTML) {\n                switch (char) {\n                    case '<':\n                        // ignore '<' if inside a quote\n                        if (in_quote_char) {\n                            break;\n                        }\n\n                        // we're seeing a nested '<'\n                        depth++;\n                        break;\n\n                    case '>':\n                        // ignore '>' if inside a quote\n                        if (in_quote_char) {\n                            break;\n                        }\n\n                        // something like this is happening: '<<>>'\n                        if (depth) {\n                            depth--;\n\n                            break;\n                        }\n\n                        // this is closing the tag in tag_buffer\n                        in_quote_char = '';\n                        state         = STATE_PLAINTEXT;\n                        tag_buffer   += '>';\n\n                        if (allowable_tags.has(normalize_tag(tag_buffer))) {\n                            output += tag_buffer;\n                        } else {\n                            output += tag_replacement;\n                        }\n\n                        tag_buffer = '';\n                        break;\n\n                    case '\"':\n                    case '\\'':\n                        // catch both single and double quotes\n\n                        if (char === in_quote_char) {\n                            in_quote_char = '';\n                        } else {\n                            in_quote_char = in_quote_char || char;\n                        }\n\n                        tag_buffer += char;\n                        break;\n\n                    case '-':\n                        if (tag_buffer === '<!-') {\n                            state = STATE_COMMENT;\n                        }\n\n                        tag_buffer += char;\n                        break;\n\n                    case ' ':\n                    case '\\n':\n                        if (tag_buffer === '<') {\n                            state      = STATE_PLAINTEXT;\n                            output    += '< ';\n                            tag_buffer = '';\n\n                            break;\n                        }\n\n                        tag_buffer += char;\n                        break;\n\n                    default:\n                        tag_buffer += char;\n                        break;\n                }\n            }\n\n            else if (state === STATE_COMMENT) {\n                switch (char) {\n                    case '>':\n                        if (tag_buffer.slice(-2) == '--') {\n                            // close the comment\n                            state = STATE_PLAINTEXT;\n                        }\n\n                        tag_buffer = '';\n                        break;\n\n                    default:\n                        tag_buffer += char;\n                        break;\n                }\n            }\n        }\n\n        // save the context for future iterations\n        context.state         = state;\n        context.tag_buffer    = tag_buffer;\n        context.depth         = depth;\n        context.in_quote_char = in_quote_char;\n\n        return output;\n    }\n\n    function parse_allowable_tags(allowable_tags) {\n        let tag_set = new Set();\n\n        if (typeof allowable_tags === 'string') {\n            let match;\n\n            while ((match = ALLOWED_TAGS_REGEX.exec(allowable_tags))) {\n                tag_set.add(match[1]);\n            }\n        }\n\n        else if (!Symbol.nonNative &&\n                 typeof allowable_tags[Symbol.iterator] === 'function') {\n\n            tag_set = new Set(allowable_tags);\n        }\n\n        else if (typeof allowable_tags.forEach === 'function') {\n            // IE11 compatible\n            allowable_tags.forEach(tag_set.add, tag_set);\n        }\n\n        return tag_set;\n    }\n\n    function normalize_tag(tag_buffer) {\n        let match = NORMALIZE_TAG_REGEX.exec(tag_buffer);\n\n        return match ? match[1].toLowerCase() : null;\n    }\n\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(function module_factory() { return striptags; });\n    }\n\n    else if (typeof module === 'object' && module.exports) {\n        // Node\n        module.exports = striptags;\n    }\n\n    else {\n        // Browser\n        global.striptags = striptags;\n    }\n}(this));\n"]},"metadata":{},"sourceType":"script"}