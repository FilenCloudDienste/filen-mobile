{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport PropTypes from 'prop-types';\nimport * as React from 'react';\nimport CollectionView from './CollectionView';\nimport _calculateSizeAndPositionData from './utils/calculateSizeAndPositionData';\nimport getUpdatedOffsetForIndex from '../utils/getUpdatedOffsetForIndex';\n/**\n * Renders scattered or non-linear data.\n * Unlike Grid, which renders checkerboard data, Collection can render arbitrarily positioned- even overlapping- data.\n */\n\nvar Collection = /*#__PURE__*/function (_React$PureComponent) {\n  _inherits(Collection, _React$PureComponent);\n\n  function Collection(props, context) {\n    var _this;\n\n    _classCallCheck(this, Collection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Collection).call(this, props, context));\n    _this._cellMetadata = [];\n    _this._lastRenderedCellIndices = []; // Cell cache during scroll (for performance)\n\n    _this._cellCache = [];\n    _this._isScrollingChange = _this._isScrollingChange.bind(_assertThisInitialized(_this));\n    _this._setCollectionViewRef = _this._setCollectionViewRef.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: \"forceUpdate\",\n    value: function forceUpdate() {\n      if (this._collectionView !== undefined) {\n        this._collectionView.forceUpdate();\n      }\n    }\n    /** See Collection#recomputeCellSizesAndPositions */\n\n  }, {\n    key: \"recomputeCellSizesAndPositions\",\n    value: function recomputeCellSizesAndPositions() {\n      this._cellCache = [];\n\n      this._collectionView.recomputeCellSizesAndPositions();\n    }\n    /** React lifecycle methods */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var props = _extends({}, this.props);\n\n      return React.createElement(CollectionView, _extends({\n        cellLayoutManager: this,\n        isScrollingChange: this._isScrollingChange,\n        ref: this._setCollectionViewRef\n      }, props));\n    }\n    /** CellLayoutManager interface */\n\n  }, {\n    key: \"calculateSizeAndPositionData\",\n    value: function calculateSizeAndPositionData() {\n      var _this$props = this.props,\n          cellCount = _this$props.cellCount,\n          cellSizeAndPositionGetter = _this$props.cellSizeAndPositionGetter,\n          sectionSize = _this$props.sectionSize;\n\n      var data = _calculateSizeAndPositionData({\n        cellCount: cellCount,\n        cellSizeAndPositionGetter: cellSizeAndPositionGetter,\n        sectionSize: sectionSize\n      });\n\n      this._cellMetadata = data.cellMetadata;\n      this._sectionManager = data.sectionManager;\n      this._height = data.height;\n      this._width = data.width;\n    }\n    /**\n     * Returns the most recently rendered set of cell indices.\n     */\n\n  }, {\n    key: \"getLastRenderedIndices\",\n    value: function getLastRenderedIndices() {\n      return this._lastRenderedCellIndices;\n    }\n    /**\n     * Calculates the minimum amount of change from the current scroll position to ensure the specified cell is (fully) visible.\n     */\n\n  }, {\n    key: \"getScrollPositionForCell\",\n    value: function getScrollPositionForCell(_ref) {\n      var align = _ref.align,\n          cellIndex = _ref.cellIndex,\n          height = _ref.height,\n          scrollLeft = _ref.scrollLeft,\n          scrollTop = _ref.scrollTop,\n          width = _ref.width;\n      var cellCount = this.props.cellCount;\n\n      if (cellIndex >= 0 && cellIndex < cellCount) {\n        var cellMetadata = this._cellMetadata[cellIndex];\n        scrollLeft = getUpdatedOffsetForIndex({\n          align: align,\n          cellOffset: cellMetadata.x,\n          cellSize: cellMetadata.width,\n          containerSize: width,\n          currentOffset: scrollLeft,\n          targetIndex: cellIndex\n        });\n        scrollTop = getUpdatedOffsetForIndex({\n          align: align,\n          cellOffset: cellMetadata.y,\n          cellSize: cellMetadata.height,\n          containerSize: height,\n          currentOffset: scrollTop,\n          targetIndex: cellIndex\n        });\n      }\n\n      return {\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n      };\n    }\n  }, {\n    key: \"getTotalSize\",\n    value: function getTotalSize() {\n      return {\n        height: this._height,\n        width: this._width\n      };\n    }\n  }, {\n    key: \"cellRenderers\",\n    value: function cellRenderers(_ref2) {\n      var _this2 = this;\n\n      var height = _ref2.height,\n          isScrolling = _ref2.isScrolling,\n          width = _ref2.width,\n          x = _ref2.x,\n          y = _ref2.y;\n      var _this$props2 = this.props,\n          cellGroupRenderer = _this$props2.cellGroupRenderer,\n          cellRenderer = _this$props2.cellRenderer; // Store for later calls to getLastRenderedIndices()\n\n      this._lastRenderedCellIndices = this._sectionManager.getCellIndices({\n        height: height,\n        width: width,\n        x: x,\n        y: y\n      });\n      return cellGroupRenderer({\n        cellCache: this._cellCache,\n        cellRenderer: cellRenderer,\n        cellSizeAndPositionGetter: function cellSizeAndPositionGetter(_ref3) {\n          var index = _ref3.index;\n          return _this2._sectionManager.getCellMetadata({\n            index: index\n          });\n        },\n        indices: this._lastRenderedCellIndices,\n        isScrolling: isScrolling\n      });\n    }\n  }, {\n    key: \"_isScrollingChange\",\n    value: function _isScrollingChange(isScrolling) {\n      if (!isScrolling) {\n        this._cellCache = [];\n      }\n    }\n  }, {\n    key: \"_setCollectionViewRef\",\n    value: function _setCollectionViewRef(ref) {\n      this._collectionView = ref;\n    }\n  }]);\n\n  return Collection;\n}(React.PureComponent);\n\n_defineProperty(Collection, \"defaultProps\", {\n  'aria-label': 'grid',\n  cellGroupRenderer: defaultCellGroupRenderer\n});\n\nexport { Collection as default };\nCollection.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  'aria-label': PropTypes.string,\n\n  /**\n   * Number of cells in Collection.\n   */\n  cellCount: PropTypes.number.isRequired,\n\n  /**\n   * Responsible for rendering a group of cells given their indices.\n   * Should implement the following interface: ({\n   *   cellSizeAndPositionGetter:Function,\n   *   indices: Array<number>,\n   *   cellRenderer: Function\n   * }): Array<PropTypes.node>\n   */\n  cellGroupRenderer: PropTypes.func.isRequired,\n\n  /**\n   * Responsible for rendering a cell given an row and column index.\n   * Should implement the following interface: ({ index: number, key: string, style: object }): PropTypes.element\n   */\n  cellRenderer: PropTypes.func.isRequired,\n\n  /**\n   * Callback responsible for returning size and offset/position information for a given cell (index).\n   * ({ index: number }): { height: number, width: number, x: number, y: number }\n   */\n  cellSizeAndPositionGetter: PropTypes.func.isRequired,\n\n  /**\n   * Optionally override the size of the sections a Collection's cells are split into.\n   */\n  sectionSize: PropTypes.number\n} : {};\n\nfunction defaultCellGroupRenderer(_ref4) {\n  var cellCache = _ref4.cellCache,\n      cellRenderer = _ref4.cellRenderer,\n      cellSizeAndPositionGetter = _ref4.cellSizeAndPositionGetter,\n      indices = _ref4.indices,\n      isScrolling = _ref4.isScrolling;\n  return indices.map(function (index) {\n    var cellMetadata = cellSizeAndPositionGetter({\n      index: index\n    });\n    var cellRendererProps = {\n      index: index,\n      isScrolling: isScrolling,\n      key: index,\n      style: {\n        height: cellMetadata.height,\n        left: cellMetadata.x,\n        position: 'absolute',\n        top: cellMetadata.y,\n        width: cellMetadata.width\n      }\n    }; // Avoid re-creating cells while scrolling.\n    // This can lead to the same cell being created many times and can cause performance issues for \"heavy\" cells.\n    // If a scroll is in progress- cache and reuse cells.\n    // This cache will be thrown away once scrolling complets.\n\n    if (isScrolling) {\n      if (!(index in cellCache)) {\n        cellCache[index] = cellRenderer(cellRendererProps);\n      }\n\n      return cellCache[index];\n    } else {\n      return cellRenderer(cellRendererProps);\n    }\n  }).filter(function (renderedCell) {\n    return !!renderedCell;\n  });\n}\n\nimport { bpfrpt_proptype_ScrollPosition } from \"./types\";\nimport { bpfrpt_proptype_SizeInfo } from \"./types\";","map":{"version":3,"sources":["/Users/jan/Documents/filen/app/node_modules/react-virtualized/dist/es/Collection/Collection.js"],"names":["_extends","_classCallCheck","_createClass","_possibleConstructorReturn","_getPrototypeOf","_assertThisInitialized","_inherits","_defineProperty","PropTypes","React","CollectionView","_calculateSizeAndPositionData","getUpdatedOffsetForIndex","Collection","_React$PureComponent","props","context","_this","call","_cellMetadata","_lastRenderedCellIndices","_cellCache","_isScrollingChange","bind","_setCollectionViewRef","key","value","forceUpdate","_collectionView","undefined","recomputeCellSizesAndPositions","render","createElement","cellLayoutManager","isScrollingChange","ref","calculateSizeAndPositionData","_this$props","cellCount","cellSizeAndPositionGetter","sectionSize","data","cellMetadata","_sectionManager","sectionManager","_height","height","_width","width","getLastRenderedIndices","getScrollPositionForCell","_ref","align","cellIndex","scrollLeft","scrollTop","cellOffset","x","cellSize","containerSize","currentOffset","targetIndex","y","getTotalSize","cellRenderers","_ref2","_this2","isScrolling","_this$props2","cellGroupRenderer","cellRenderer","getCellIndices","cellCache","_ref3","index","getCellMetadata","indices","PureComponent","defaultCellGroupRenderer","default","propTypes","process","env","NODE_ENV","string","number","isRequired","func","_ref4","map","cellRendererProps","style","left","position","top","filter","renderedCell","bpfrpt_proptype_ScrollPosition","bpfrpt_proptype_SizeInfo"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,gCAArB;AACA,OAAOC,eAAP,MAA4B,uCAA5B;AACA,OAAOC,YAAP,MAAyB,oCAAzB;AACA,OAAOC,0BAAP,MAAuC,kDAAvC;AACA,OAAOC,eAAP,MAA4B,uCAA5B;AACA,OAAOC,sBAAP,MAAmC,8CAAnC;AACA,OAAOC,SAAP,MAAsB,iCAAtB;AACA,OAAOC,eAAP,MAA4B,uCAA5B;AACA,OAAOC,SAAP,MAAsB,YAAtB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,OAAOC,cAAP,MAA2B,kBAA3B;AACA,OAAOC,6BAAP,MAA0C,sCAA1C;AACA,OAAOC,wBAAP,MAAqC,mCAArC;AAEA;AACA;AACA;AACA;;AACA,IAAIC,UAAU,GACd,aACA,UAAUC,oBAAV,EAAgC;AAC9BR,EAAAA,SAAS,CAACO,UAAD,EAAaC,oBAAb,CAAT;;AAEA,WAASD,UAAT,CAAoBE,KAApB,EAA2BC,OAA3B,EAAoC;AAClC,QAAIC,KAAJ;;AAEAhB,IAAAA,eAAe,CAAC,IAAD,EAAOY,UAAP,CAAf;;AAEAI,IAAAA,KAAK,GAAGd,0BAA0B,CAAC,IAAD,EAAOC,eAAe,CAACS,UAAD,CAAf,CAA4BK,IAA5B,CAAiC,IAAjC,EAAuCH,KAAvC,EAA8CC,OAA9C,CAAP,CAAlC;AACAC,IAAAA,KAAK,CAACE,aAAN,GAAsB,EAAtB;AACAF,IAAAA,KAAK,CAACG,wBAAN,GAAiC,EAAjC,CAPkC,CAOG;;AAErCH,IAAAA,KAAK,CAACI,UAAN,GAAmB,EAAnB;AACAJ,IAAAA,KAAK,CAACK,kBAAN,GAA2BL,KAAK,CAACK,kBAAN,CAAyBC,IAAzB,CAA8BlB,sBAAsB,CAACY,KAAD,CAApD,CAA3B;AACAA,IAAAA,KAAK,CAACO,qBAAN,GAA8BP,KAAK,CAACO,qBAAN,CAA4BD,IAA5B,CAAiClB,sBAAsB,CAACY,KAAD,CAAvD,CAA9B;AACA,WAAOA,KAAP;AACD;;AAEDf,EAAAA,YAAY,CAACW,UAAD,EAAa,CAAC;AACxBY,IAAAA,GAAG,EAAE,aADmB;AAExBC,IAAAA,KAAK,EAAE,SAASC,WAAT,GAAuB;AAC5B,UAAI,KAAKC,eAAL,KAAyBC,SAA7B,EAAwC;AACtC,aAAKD,eAAL,CAAqBD,WAArB;AACD;AACF;AACD;;AAPwB,GAAD,EAStB;AACDF,IAAAA,GAAG,EAAE,gCADJ;AAEDC,IAAAA,KAAK,EAAE,SAASI,8BAAT,GAA0C;AAC/C,WAAKT,UAAL,GAAkB,EAAlB;;AAEA,WAAKO,eAAL,CAAqBE,8BAArB;AACD;AACD;;AAPC,GATsB,EAkBtB;AACDL,IAAAA,GAAG,EAAE,QADJ;AAEDC,IAAAA,KAAK,EAAE,SAASK,MAAT,GAAkB;AACvB,UAAIhB,KAAK,GAAGf,QAAQ,CAAC,EAAD,EAAK,KAAKe,KAAV,CAApB;;AAEA,aAAON,KAAK,CAACuB,aAAN,CAAoBtB,cAApB,EAAoCV,QAAQ,CAAC;AAClDiC,QAAAA,iBAAiB,EAAE,IAD+B;AAElDC,QAAAA,iBAAiB,EAAE,KAAKZ,kBAF0B;AAGlDa,QAAAA,GAAG,EAAE,KAAKX;AAHwC,OAAD,EAIhDT,KAJgD,CAA5C,CAAP;AAKD;AACD;;AAXC,GAlBsB,EA+BtB;AACDU,IAAAA,GAAG,EAAE,8BADJ;AAEDC,IAAAA,KAAK,EAAE,SAASU,4BAAT,GAAwC;AAC7C,UAAIC,WAAW,GAAG,KAAKtB,KAAvB;AAAA,UACIuB,SAAS,GAAGD,WAAW,CAACC,SAD5B;AAAA,UAEIC,yBAAyB,GAAGF,WAAW,CAACE,yBAF5C;AAAA,UAGIC,WAAW,GAAGH,WAAW,CAACG,WAH9B;;AAKA,UAAIC,IAAI,GAAG9B,6BAA6B,CAAC;AACvC2B,QAAAA,SAAS,EAAEA,SAD4B;AAEvCC,QAAAA,yBAAyB,EAAEA,yBAFY;AAGvCC,QAAAA,WAAW,EAAEA;AAH0B,OAAD,CAAxC;;AAMA,WAAKrB,aAAL,GAAqBsB,IAAI,CAACC,YAA1B;AACA,WAAKC,eAAL,GAAuBF,IAAI,CAACG,cAA5B;AACA,WAAKC,OAAL,GAAeJ,IAAI,CAACK,MAApB;AACA,WAAKC,MAAL,GAAcN,IAAI,CAACO,KAAnB;AACD;AACD;AACJ;AACA;;AArBK,GA/BsB,EAsDtB;AACDvB,IAAAA,GAAG,EAAE,wBADJ;AAEDC,IAAAA,KAAK,EAAE,SAASuB,sBAAT,GAAkC;AACvC,aAAO,KAAK7B,wBAAZ;AACD;AACD;AACJ;AACA;;AAPK,GAtDsB,EA+DtB;AACDK,IAAAA,GAAG,EAAE,0BADJ;AAEDC,IAAAA,KAAK,EAAE,SAASwB,wBAAT,CAAkCC,IAAlC,EAAwC;AAC7C,UAAIC,KAAK,GAAGD,IAAI,CAACC,KAAjB;AAAA,UACIC,SAAS,GAAGF,IAAI,CAACE,SADrB;AAAA,UAEIP,MAAM,GAAGK,IAAI,CAACL,MAFlB;AAAA,UAGIQ,UAAU,GAAGH,IAAI,CAACG,UAHtB;AAAA,UAIIC,SAAS,GAAGJ,IAAI,CAACI,SAJrB;AAAA,UAKIP,KAAK,GAAGG,IAAI,CAACH,KALjB;AAMA,UAAIV,SAAS,GAAG,KAAKvB,KAAL,CAAWuB,SAA3B;;AAEA,UAAIe,SAAS,IAAI,CAAb,IAAkBA,SAAS,GAAGf,SAAlC,EAA6C;AAC3C,YAAII,YAAY,GAAG,KAAKvB,aAAL,CAAmBkC,SAAnB,CAAnB;AACAC,QAAAA,UAAU,GAAG1C,wBAAwB,CAAC;AACpCwC,UAAAA,KAAK,EAAEA,KAD6B;AAEpCI,UAAAA,UAAU,EAAEd,YAAY,CAACe,CAFW;AAGpCC,UAAAA,QAAQ,EAAEhB,YAAY,CAACM,KAHa;AAIpCW,UAAAA,aAAa,EAAEX,KAJqB;AAKpCY,UAAAA,aAAa,EAAEN,UALqB;AAMpCO,UAAAA,WAAW,EAAER;AANuB,SAAD,CAArC;AAQAE,QAAAA,SAAS,GAAG3C,wBAAwB,CAAC;AACnCwC,UAAAA,KAAK,EAAEA,KAD4B;AAEnCI,UAAAA,UAAU,EAAEd,YAAY,CAACoB,CAFU;AAGnCJ,UAAAA,QAAQ,EAAEhB,YAAY,CAACI,MAHY;AAInCa,UAAAA,aAAa,EAAEb,MAJoB;AAKnCc,UAAAA,aAAa,EAAEL,SALoB;AAMnCM,UAAAA,WAAW,EAAER;AANsB,SAAD,CAApC;AAQD;;AAED,aAAO;AACLC,QAAAA,UAAU,EAAEA,UADP;AAELC,QAAAA,SAAS,EAAEA;AAFN,OAAP;AAID;AAnCA,GA/DsB,EAmGtB;AACD9B,IAAAA,GAAG,EAAE,cADJ;AAEDC,IAAAA,KAAK,EAAE,SAASqC,YAAT,GAAwB;AAC7B,aAAO;AACLjB,QAAAA,MAAM,EAAE,KAAKD,OADR;AAELG,QAAAA,KAAK,EAAE,KAAKD;AAFP,OAAP;AAID;AAPA,GAnGsB,EA2GtB;AACDtB,IAAAA,GAAG,EAAE,eADJ;AAEDC,IAAAA,KAAK,EAAE,SAASsC,aAAT,CAAuBC,KAAvB,EAA8B;AACnC,UAAIC,MAAM,GAAG,IAAb;;AAEA,UAAIpB,MAAM,GAAGmB,KAAK,CAACnB,MAAnB;AAAA,UACIqB,WAAW,GAAGF,KAAK,CAACE,WADxB;AAAA,UAEInB,KAAK,GAAGiB,KAAK,CAACjB,KAFlB;AAAA,UAGIS,CAAC,GAAGQ,KAAK,CAACR,CAHd;AAAA,UAIIK,CAAC,GAAGG,KAAK,CAACH,CAJd;AAKA,UAAIM,YAAY,GAAG,KAAKrD,KAAxB;AAAA,UACIsD,iBAAiB,GAAGD,YAAY,CAACC,iBADrC;AAAA,UAEIC,YAAY,GAAGF,YAAY,CAACE,YAFhC,CARmC,CAUW;;AAE9C,WAAKlD,wBAAL,GAAgC,KAAKuB,eAAL,CAAqB4B,cAArB,CAAoC;AAClEzB,QAAAA,MAAM,EAAEA,MAD0D;AAElEE,QAAAA,KAAK,EAAEA,KAF2D;AAGlES,QAAAA,CAAC,EAAEA,CAH+D;AAIlEK,QAAAA,CAAC,EAAEA;AAJ+D,OAApC,CAAhC;AAMA,aAAOO,iBAAiB,CAAC;AACvBG,QAAAA,SAAS,EAAE,KAAKnD,UADO;AAEvBiD,QAAAA,YAAY,EAAEA,YAFS;AAGvB/B,QAAAA,yBAAyB,EAAE,SAASA,yBAAT,CAAmCkC,KAAnC,EAA0C;AACnE,cAAIC,KAAK,GAAGD,KAAK,CAACC,KAAlB;AACA,iBAAOR,MAAM,CAACvB,eAAP,CAAuBgC,eAAvB,CAAuC;AAC5CD,YAAAA,KAAK,EAAEA;AADqC,WAAvC,CAAP;AAGD,SARsB;AASvBE,QAAAA,OAAO,EAAE,KAAKxD,wBATS;AAUvB+C,QAAAA,WAAW,EAAEA;AAVU,OAAD,CAAxB;AAYD;AAhCA,GA3GsB,EA4ItB;AACD1C,IAAAA,GAAG,EAAE,oBADJ;AAEDC,IAAAA,KAAK,EAAE,SAASJ,kBAAT,CAA4B6C,WAA5B,EAAyC;AAC9C,UAAI,CAACA,WAAL,EAAkB;AAChB,aAAK9C,UAAL,GAAkB,EAAlB;AACD;AACF;AANA,GA5IsB,EAmJtB;AACDI,IAAAA,GAAG,EAAE,uBADJ;AAEDC,IAAAA,KAAK,EAAE,SAASF,qBAAT,CAA+BW,GAA/B,EAAoC;AACzC,WAAKP,eAAL,GAAuBO,GAAvB;AACD;AAJA,GAnJsB,CAAb,CAAZ;;AA0JA,SAAOtB,UAAP;AACD,CA7KD,CA6KEJ,KAAK,CAACoE,aA7KR,CAFA;;AAiLAtE,eAAe,CAACM,UAAD,EAAa,cAAb,EAA6B;AAC1C,gBAAc,MAD4B;AAE1CwD,EAAAA,iBAAiB,EAAES;AAFuB,CAA7B,CAAf;;AAKA,SAASjE,UAAU,IAAIkE,OAAvB;AACAlE,UAAU,CAACmE,SAAX,GAAuBC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwC;AAC7D,gBAAc3E,SAAS,CAAC4E,MADqC;;AAG7D;AACF;AACA;AACE9C,EAAAA,SAAS,EAAE9B,SAAS,CAAC6E,MAAV,CAAiBC,UANiC;;AAQ7D;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEjB,EAAAA,iBAAiB,EAAE7D,SAAS,CAAC+E,IAAV,CAAeD,UAhB2B;;AAkB7D;AACF;AACA;AACA;AACEhB,EAAAA,YAAY,EAAE9D,SAAS,CAAC+E,IAAV,CAAeD,UAtBgC;;AAwB7D;AACF;AACA;AACA;AACE/C,EAAAA,yBAAyB,EAAE/B,SAAS,CAAC+E,IAAV,CAAeD,UA5BmB;;AA8B7D;AACF;AACA;AACE9C,EAAAA,WAAW,EAAEhC,SAAS,CAAC6E;AAjCsC,CAAxC,GAkCnB,EAlCJ;;AAoCA,SAASP,wBAAT,CAAkCU,KAAlC,EAAyC;AACvC,MAAIhB,SAAS,GAAGgB,KAAK,CAAChB,SAAtB;AAAA,MACIF,YAAY,GAAGkB,KAAK,CAAClB,YADzB;AAAA,MAEI/B,yBAAyB,GAAGiD,KAAK,CAACjD,yBAFtC;AAAA,MAGIqC,OAAO,GAAGY,KAAK,CAACZ,OAHpB;AAAA,MAIIT,WAAW,GAAGqB,KAAK,CAACrB,WAJxB;AAKA,SAAOS,OAAO,CAACa,GAAR,CAAY,UAAUf,KAAV,EAAiB;AAClC,QAAIhC,YAAY,GAAGH,yBAAyB,CAAC;AAC3CmC,MAAAA,KAAK,EAAEA;AADoC,KAAD,CAA5C;AAGA,QAAIgB,iBAAiB,GAAG;AACtBhB,MAAAA,KAAK,EAAEA,KADe;AAEtBP,MAAAA,WAAW,EAAEA,WAFS;AAGtB1C,MAAAA,GAAG,EAAEiD,KAHiB;AAItBiB,MAAAA,KAAK,EAAE;AACL7C,QAAAA,MAAM,EAAEJ,YAAY,CAACI,MADhB;AAEL8C,QAAAA,IAAI,EAAElD,YAAY,CAACe,CAFd;AAGLoC,QAAAA,QAAQ,EAAE,UAHL;AAILC,QAAAA,GAAG,EAAEpD,YAAY,CAACoB,CAJb;AAKLd,QAAAA,KAAK,EAAEN,YAAY,CAACM;AALf;AAJe,KAAxB,CAJkC,CAe/B;AACH;AACA;AACA;;AAEA,QAAImB,WAAJ,EAAiB;AACf,UAAI,EAAEO,KAAK,IAAIF,SAAX,CAAJ,EAA2B;AACzBA,QAAAA,SAAS,CAACE,KAAD,CAAT,GAAmBJ,YAAY,CAACoB,iBAAD,CAA/B;AACD;;AAED,aAAOlB,SAAS,CAACE,KAAD,CAAhB;AACD,KAND,MAMO;AACL,aAAOJ,YAAY,CAACoB,iBAAD,CAAnB;AACD;AACF,GA7BM,EA6BJK,MA7BI,CA6BG,UAAUC,YAAV,EAAwB;AAChC,WAAO,CAAC,CAACA,YAAT;AACD,GA/BM,CAAP;AAgCD;;AAED,SAASC,8BAAT,QAA+C,SAA/C;AACA,SAASC,wBAAT,QAAyC,SAAzC","sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport PropTypes from 'prop-types';\nimport * as React from 'react';\nimport CollectionView from './CollectionView';\nimport _calculateSizeAndPositionData from './utils/calculateSizeAndPositionData';\nimport getUpdatedOffsetForIndex from '../utils/getUpdatedOffsetForIndex';\n\n/**\n * Renders scattered or non-linear data.\n * Unlike Grid, which renders checkerboard data, Collection can render arbitrarily positioned- even overlapping- data.\n */\nvar Collection =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(Collection, _React$PureComponent);\n\n  function Collection(props, context) {\n    var _this;\n\n    _classCallCheck(this, Collection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Collection).call(this, props, context));\n    _this._cellMetadata = [];\n    _this._lastRenderedCellIndices = []; // Cell cache during scroll (for performance)\n\n    _this._cellCache = [];\n    _this._isScrollingChange = _this._isScrollingChange.bind(_assertThisInitialized(_this));\n    _this._setCollectionViewRef = _this._setCollectionViewRef.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: \"forceUpdate\",\n    value: function forceUpdate() {\n      if (this._collectionView !== undefined) {\n        this._collectionView.forceUpdate();\n      }\n    }\n    /** See Collection#recomputeCellSizesAndPositions */\n\n  }, {\n    key: \"recomputeCellSizesAndPositions\",\n    value: function recomputeCellSizesAndPositions() {\n      this._cellCache = [];\n\n      this._collectionView.recomputeCellSizesAndPositions();\n    }\n    /** React lifecycle methods */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var props = _extends({}, this.props);\n\n      return React.createElement(CollectionView, _extends({\n        cellLayoutManager: this,\n        isScrollingChange: this._isScrollingChange,\n        ref: this._setCollectionViewRef\n      }, props));\n    }\n    /** CellLayoutManager interface */\n\n  }, {\n    key: \"calculateSizeAndPositionData\",\n    value: function calculateSizeAndPositionData() {\n      var _this$props = this.props,\n          cellCount = _this$props.cellCount,\n          cellSizeAndPositionGetter = _this$props.cellSizeAndPositionGetter,\n          sectionSize = _this$props.sectionSize;\n\n      var data = _calculateSizeAndPositionData({\n        cellCount: cellCount,\n        cellSizeAndPositionGetter: cellSizeAndPositionGetter,\n        sectionSize: sectionSize\n      });\n\n      this._cellMetadata = data.cellMetadata;\n      this._sectionManager = data.sectionManager;\n      this._height = data.height;\n      this._width = data.width;\n    }\n    /**\n     * Returns the most recently rendered set of cell indices.\n     */\n\n  }, {\n    key: \"getLastRenderedIndices\",\n    value: function getLastRenderedIndices() {\n      return this._lastRenderedCellIndices;\n    }\n    /**\n     * Calculates the minimum amount of change from the current scroll position to ensure the specified cell is (fully) visible.\n     */\n\n  }, {\n    key: \"getScrollPositionForCell\",\n    value: function getScrollPositionForCell(_ref) {\n      var align = _ref.align,\n          cellIndex = _ref.cellIndex,\n          height = _ref.height,\n          scrollLeft = _ref.scrollLeft,\n          scrollTop = _ref.scrollTop,\n          width = _ref.width;\n      var cellCount = this.props.cellCount;\n\n      if (cellIndex >= 0 && cellIndex < cellCount) {\n        var cellMetadata = this._cellMetadata[cellIndex];\n        scrollLeft = getUpdatedOffsetForIndex({\n          align: align,\n          cellOffset: cellMetadata.x,\n          cellSize: cellMetadata.width,\n          containerSize: width,\n          currentOffset: scrollLeft,\n          targetIndex: cellIndex\n        });\n        scrollTop = getUpdatedOffsetForIndex({\n          align: align,\n          cellOffset: cellMetadata.y,\n          cellSize: cellMetadata.height,\n          containerSize: height,\n          currentOffset: scrollTop,\n          targetIndex: cellIndex\n        });\n      }\n\n      return {\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n      };\n    }\n  }, {\n    key: \"getTotalSize\",\n    value: function getTotalSize() {\n      return {\n        height: this._height,\n        width: this._width\n      };\n    }\n  }, {\n    key: \"cellRenderers\",\n    value: function cellRenderers(_ref2) {\n      var _this2 = this;\n\n      var height = _ref2.height,\n          isScrolling = _ref2.isScrolling,\n          width = _ref2.width,\n          x = _ref2.x,\n          y = _ref2.y;\n      var _this$props2 = this.props,\n          cellGroupRenderer = _this$props2.cellGroupRenderer,\n          cellRenderer = _this$props2.cellRenderer; // Store for later calls to getLastRenderedIndices()\n\n      this._lastRenderedCellIndices = this._sectionManager.getCellIndices({\n        height: height,\n        width: width,\n        x: x,\n        y: y\n      });\n      return cellGroupRenderer({\n        cellCache: this._cellCache,\n        cellRenderer: cellRenderer,\n        cellSizeAndPositionGetter: function cellSizeAndPositionGetter(_ref3) {\n          var index = _ref3.index;\n          return _this2._sectionManager.getCellMetadata({\n            index: index\n          });\n        },\n        indices: this._lastRenderedCellIndices,\n        isScrolling: isScrolling\n      });\n    }\n  }, {\n    key: \"_isScrollingChange\",\n    value: function _isScrollingChange(isScrolling) {\n      if (!isScrolling) {\n        this._cellCache = [];\n      }\n    }\n  }, {\n    key: \"_setCollectionViewRef\",\n    value: function _setCollectionViewRef(ref) {\n      this._collectionView = ref;\n    }\n  }]);\n\n  return Collection;\n}(React.PureComponent);\n\n_defineProperty(Collection, \"defaultProps\", {\n  'aria-label': 'grid',\n  cellGroupRenderer: defaultCellGroupRenderer\n});\n\nexport { Collection as default };\nCollection.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  'aria-label': PropTypes.string,\n\n  /**\n   * Number of cells in Collection.\n   */\n  cellCount: PropTypes.number.isRequired,\n\n  /**\n   * Responsible for rendering a group of cells given their indices.\n   * Should implement the following interface: ({\n   *   cellSizeAndPositionGetter:Function,\n   *   indices: Array<number>,\n   *   cellRenderer: Function\n   * }): Array<PropTypes.node>\n   */\n  cellGroupRenderer: PropTypes.func.isRequired,\n\n  /**\n   * Responsible for rendering a cell given an row and column index.\n   * Should implement the following interface: ({ index: number, key: string, style: object }): PropTypes.element\n   */\n  cellRenderer: PropTypes.func.isRequired,\n\n  /**\n   * Callback responsible for returning size and offset/position information for a given cell (index).\n   * ({ index: number }): { height: number, width: number, x: number, y: number }\n   */\n  cellSizeAndPositionGetter: PropTypes.func.isRequired,\n\n  /**\n   * Optionally override the size of the sections a Collection's cells are split into.\n   */\n  sectionSize: PropTypes.number\n} : {};\n\nfunction defaultCellGroupRenderer(_ref4) {\n  var cellCache = _ref4.cellCache,\n      cellRenderer = _ref4.cellRenderer,\n      cellSizeAndPositionGetter = _ref4.cellSizeAndPositionGetter,\n      indices = _ref4.indices,\n      isScrolling = _ref4.isScrolling;\n  return indices.map(function (index) {\n    var cellMetadata = cellSizeAndPositionGetter({\n      index: index\n    });\n    var cellRendererProps = {\n      index: index,\n      isScrolling: isScrolling,\n      key: index,\n      style: {\n        height: cellMetadata.height,\n        left: cellMetadata.x,\n        position: 'absolute',\n        top: cellMetadata.y,\n        width: cellMetadata.width\n      }\n    }; // Avoid re-creating cells while scrolling.\n    // This can lead to the same cell being created many times and can cause performance issues for \"heavy\" cells.\n    // If a scroll is in progress- cache and reuse cells.\n    // This cache will be thrown away once scrolling complets.\n\n    if (isScrolling) {\n      if (!(index in cellCache)) {\n        cellCache[index] = cellRenderer(cellRendererProps);\n      }\n\n      return cellCache[index];\n    } else {\n      return cellRenderer(cellRendererProps);\n    }\n  }).filter(function (renderedCell) {\n    return !!renderedCell;\n  });\n}\n\nimport { bpfrpt_proptype_ScrollPosition } from \"./types\";\nimport { bpfrpt_proptype_SizeInfo } from \"./types\";"]},"metadata":{},"sourceType":"module"}