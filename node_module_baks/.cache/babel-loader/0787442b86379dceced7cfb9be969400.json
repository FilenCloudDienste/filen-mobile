{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport clsx from 'clsx';\nimport PropTypes from 'prop-types';\nimport * as React from 'react';\nimport { polyfill } from 'react-lifecycles-compat';\nimport createCallbackMemoizer from '../utils/createCallbackMemoizer';\nimport getScrollbarSize from 'dom-helpers/scrollbarSize'; // @TODO Merge Collection and CollectionView\n\n/**\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\n * This improves performance and makes scrolling smoother.\n */\n\nvar IS_SCROLLING_TIMEOUT = 150;\n/**\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\n */\n\nvar SCROLL_POSITION_CHANGE_REASONS = {\n  OBSERVED: 'observed',\n  REQUESTED: 'requested'\n};\n/**\n * Monitors changes in properties (eg. cellCount) and state (eg. scroll offsets) to determine when rendering needs to occur.\n * This component does not render any visible content itself; it defers to the specified :cellLayoutManager.\n */\n\nvar CollectionView = /*#__PURE__*/function (_React$PureComponent) {\n  _inherits(CollectionView, _React$PureComponent); // Invokes callbacks only when their values have changed.\n\n\n  function CollectionView() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, CollectionView);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(CollectionView)).call.apply(_getPrototypeOf2, [this].concat(args))); // If this component is being rendered server-side, getScrollbarSize() will return undefined.\n    // We handle this case in componentDidMount()\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      isScrolling: false,\n      scrollLeft: 0,\n      scrollTop: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_calculateSizeAndPositionDataOnNextUpdate\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_onSectionRenderedMemoizer\", createCallbackMemoizer());\n\n    _defineProperty(_assertThisInitialized(_this), \"_onScrollMemoizer\", createCallbackMemoizer(false));\n\n    _defineProperty(_assertThisInitialized(_this), \"_invokeOnSectionRenderedHelper\", function () {\n      var _this$props = _this.props,\n          cellLayoutManager = _this$props.cellLayoutManager,\n          onSectionRendered = _this$props.onSectionRendered;\n\n      _this._onSectionRenderedMemoizer({\n        callback: onSectionRendered,\n        indices: {\n          indices: cellLayoutManager.getLastRenderedIndices()\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_setScrollingContainerRef\", function (ref) {\n      _this._scrollingContainer = ref;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_updateScrollPositionForScrollToCell\", function () {\n      var _this$props2 = _this.props,\n          cellLayoutManager = _this$props2.cellLayoutManager,\n          height = _this$props2.height,\n          scrollToAlignment = _this$props2.scrollToAlignment,\n          scrollToCell = _this$props2.scrollToCell,\n          width = _this$props2.width;\n      var _this$state = _this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n\n      if (scrollToCell >= 0) {\n        var scrollPosition = cellLayoutManager.getScrollPositionForCell({\n          align: scrollToAlignment,\n          cellIndex: scrollToCell,\n          height: height,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          width: width\n        });\n\n        if (scrollPosition.scrollLeft !== scrollLeft || scrollPosition.scrollTop !== scrollTop) {\n          _this._setScrollPosition(scrollPosition);\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_onScroll\", function (event) {\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\n      // See issue #404 for more information.\n      if (event.target !== _this._scrollingContainer) {\n        return;\n      } // Prevent pointer events from interrupting a smooth scroll\n\n\n      _this._enablePointerEventsAfterDelay(); // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\n      // This causes a series of rapid renders that is slow for long lists.\n      // We can avoid that by doing some simple bounds checking to ensure that scrollTop never exceeds the total height.\n\n\n      var _this$props3 = _this.props,\n          cellLayoutManager = _this$props3.cellLayoutManager,\n          height = _this$props3.height,\n          isScrollingChange = _this$props3.isScrollingChange,\n          width = _this$props3.width;\n      var scrollbarSize = _this._scrollbarSize;\n\n      var _cellLayoutManager$ge = cellLayoutManager.getTotalSize(),\n          totalHeight = _cellLayoutManager$ge.height,\n          totalWidth = _cellLayoutManager$ge.width;\n\n      var scrollLeft = Math.max(0, Math.min(totalWidth - width + scrollbarSize, event.target.scrollLeft));\n      var scrollTop = Math.max(0, Math.min(totalHeight - height + scrollbarSize, event.target.scrollTop)); // Certain devices (like Apple touchpad) rapid-fire duplicate events.\n      // Don't force a re-render if this is the case.\n      // The mouse may move faster then the animation frame does.\n      // Use requestAnimationFrame to avoid over-updating.\n\n      if (_this.state.scrollLeft !== scrollLeft || _this.state.scrollTop !== scrollTop) {\n        // Browsers with cancelable scroll events (eg. Firefox) interrupt scrolling animations if scrollTop/scrollLeft is set.\n        // Other browsers (eg. Safari) don't scroll as well without the help under certain conditions (DOM or style changes during scrolling).\n        // All things considered, this seems to be the best current work around that I'm aware of.\n        // For more information see https://github.com/bvaughn/react-virtualized/pull/124\n        var scrollPositionChangeReason = event.cancelable ? SCROLL_POSITION_CHANGE_REASONS.OBSERVED : SCROLL_POSITION_CHANGE_REASONS.REQUESTED; // Synchronously set :isScrolling the first time (since _setNextState will reschedule its animation frame each time it's called)\n\n        if (!_this.state.isScrolling) {\n          isScrollingChange(true);\n        }\n\n        _this.setState({\n          isScrolling: true,\n          scrollLeft: scrollLeft,\n          scrollPositionChangeReason: scrollPositionChangeReason,\n          scrollTop: scrollTop\n        });\n      }\n\n      _this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop,\n        totalWidth: totalWidth,\n        totalHeight: totalHeight\n      });\n    });\n\n    _this._scrollbarSize = getScrollbarSize();\n\n    if (_this._scrollbarSize === undefined) {\n      _this._scrollbarSizeMeasured = false;\n      _this._scrollbarSize = 0;\n    } else {\n      _this._scrollbarSizeMeasured = true;\n    }\n\n    return _this;\n  }\n  /**\n   * Forced recompute of cell sizes and positions.\n   * This function should be called if cell sizes have changed but nothing else has.\n   * Since cell positions are calculated by callbacks, the collection view has no way of detecting when the underlying data has changed.\n   */\n\n\n  _createClass(CollectionView, [{\n    key: \"recomputeCellSizesAndPositions\",\n    value: function recomputeCellSizesAndPositions() {\n      this._calculateSizeAndPositionDataOnNextUpdate = true;\n      this.forceUpdate();\n    }\n    /* ---------------------------- Component lifecycle methods ---------------------------- */\n\n    /**\n     * @private\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) Empty content (0 rows or columns)\n     * 2) New scroll props overriding the current state\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\n     */\n\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props4 = this.props,\n          cellLayoutManager = _this$props4.cellLayoutManager,\n          scrollLeft = _this$props4.scrollLeft,\n          scrollToCell = _this$props4.scrollToCell,\n          scrollTop = _this$props4.scrollTop; // If this component was first rendered server-side, scrollbar size will be undefined.\n      // In that event we need to remeasure.\n\n      if (!this._scrollbarSizeMeasured) {\n        this._scrollbarSize = getScrollbarSize();\n        this._scrollbarSizeMeasured = true;\n        this.setState({});\n      }\n\n      if (scrollToCell >= 0) {\n        this._updateScrollPositionForScrollToCell();\n      } else if (scrollLeft >= 0 || scrollTop >= 0) {\n        this._setScrollPosition({\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        });\n      } // Update onSectionRendered callback.\n\n\n      this._invokeOnSectionRenderedHelper();\n\n      var _cellLayoutManager$ge2 = cellLayoutManager.getTotalSize(),\n          totalHeight = _cellLayoutManager$ge2.height,\n          totalWidth = _cellLayoutManager$ge2.width; // Initialize onScroll callback.\n\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft || 0,\n        scrollTop: scrollTop || 0,\n        totalHeight: totalHeight,\n        totalWidth: totalWidth\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this$props5 = this.props,\n          height = _this$props5.height,\n          scrollToAlignment = _this$props5.scrollToAlignment,\n          scrollToCell = _this$props5.scrollToCell,\n          width = _this$props5.width;\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollPositionChangeReason = _this$state2.scrollPositionChangeReason,\n          scrollTop = _this$state2.scrollTop; // Make sure requested changes to :scrollLeft or :scrollTop get applied.\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\n      // So we only set these when we require an adjustment of the scroll position.\n      // See issue #2 for more information.\n\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\n        if (scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft && scrollLeft !== this._scrollingContainer.scrollLeft) {\n          this._scrollingContainer.scrollLeft = scrollLeft;\n        }\n\n        if (scrollTop >= 0 && scrollTop !== prevState.scrollTop && scrollTop !== this._scrollingContainer.scrollTop) {\n          this._scrollingContainer.scrollTop = scrollTop;\n        }\n      } // Update scroll offsets if the current :scrollToCell values requires it\n\n\n      if (height !== prevProps.height || scrollToAlignment !== prevProps.scrollToAlignment || scrollToCell !== prevProps.scrollToCell || width !== prevProps.width) {\n        this._updateScrollPositionForScrollToCell();\n      } // Update onRowsRendered callback if start/stop indices have changed\n\n\n      this._invokeOnSectionRenderedHelper();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this._disablePointerEventsTimeoutId) {\n        clearTimeout(this._disablePointerEventsTimeoutId);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props6 = this.props,\n          autoHeight = _this$props6.autoHeight,\n          cellCount = _this$props6.cellCount,\n          cellLayoutManager = _this$props6.cellLayoutManager,\n          className = _this$props6.className,\n          height = _this$props6.height,\n          horizontalOverscanSize = _this$props6.horizontalOverscanSize,\n          id = _this$props6.id,\n          noContentRenderer = _this$props6.noContentRenderer,\n          style = _this$props6.style,\n          verticalOverscanSize = _this$props6.verticalOverscanSize,\n          width = _this$props6.width;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollLeft = _this$state3.scrollLeft,\n          scrollTop = _this$state3.scrollTop; // Memoization reset\n\n      if (this._lastRenderedCellCount !== cellCount || this._lastRenderedCellLayoutManager !== cellLayoutManager || this._calculateSizeAndPositionDataOnNextUpdate) {\n        this._lastRenderedCellCount = cellCount;\n        this._lastRenderedCellLayoutManager = cellLayoutManager;\n        this._calculateSizeAndPositionDataOnNextUpdate = false;\n        cellLayoutManager.calculateSizeAndPositionData();\n      }\n\n      var _cellLayoutManager$ge3 = cellLayoutManager.getTotalSize(),\n          totalHeight = _cellLayoutManager$ge3.height,\n          totalWidth = _cellLayoutManager$ge3.width; // Safely expand the rendered area by the specified overscan amount\n\n\n      var left = Math.max(0, scrollLeft - horizontalOverscanSize);\n      var top = Math.max(0, scrollTop - verticalOverscanSize);\n      var right = Math.min(totalWidth, scrollLeft + width + horizontalOverscanSize);\n      var bottom = Math.min(totalHeight, scrollTop + height + verticalOverscanSize);\n      var childrenToDisplay = height > 0 && width > 0 ? cellLayoutManager.cellRenderers({\n        height: bottom - top,\n        isScrolling: isScrolling,\n        width: right - left,\n        x: left,\n        y: top\n      }) : [];\n      var collectionStyle = {\n        boxSizing: 'border-box',\n        direction: 'ltr',\n        height: autoHeight ? 'auto' : height,\n        position: 'relative',\n        WebkitOverflowScrolling: 'touch',\n        width: width,\n        willChange: 'transform'\n      }; // Force browser to hide scrollbars when we know they aren't necessary.\n      // Otherwise once scrollbars appear they may not disappear again.\n      // For more info see issue #116\n\n      var verticalScrollBarSize = totalHeight > height ? this._scrollbarSize : 0;\n      var horizontalScrollBarSize = totalWidth > width ? this._scrollbarSize : 0; // Also explicitly init styles to 'auto' if scrollbars are required.\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\n      // But an initial scroll index of offset is set as an external prop.\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\n\n      collectionStyle.overflowX = totalWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\n      collectionStyle.overflowY = totalHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\n      return React.createElement(\"div\", {\n        ref: this._setScrollingContainerRef,\n        \"aria-label\": this.props['aria-label'],\n        className: clsx('ReactVirtualized__Collection', className),\n        id: id,\n        onScroll: this._onScroll,\n        role: \"grid\",\n        style: _objectSpread({}, collectionStyle, {}, style),\n        tabIndex: 0\n      }, cellCount > 0 && React.createElement(\"div\", {\n        className: \"ReactVirtualized__Collection__innerScrollContainer\",\n        style: {\n          height: totalHeight,\n          maxHeight: totalHeight,\n          maxWidth: totalWidth,\n          overflow: 'hidden',\n          pointerEvents: isScrolling ? 'none' : '',\n          width: totalWidth\n        }\n      }, childrenToDisplay), cellCount === 0 && noContentRenderer());\n    }\n    /* ---------------------------- Helper methods ---------------------------- */\n\n    /**\n     * Sets an :isScrolling flag for a small window of time.\n     * This flag is used to disable pointer events on the scrollable portion of the Collection.\n     * This prevents jerky/stuttery mouse-wheel scrolling.\n     */\n\n  }, {\n    key: \"_enablePointerEventsAfterDelay\",\n    value: function _enablePointerEventsAfterDelay() {\n      var _this2 = this;\n\n      if (this._disablePointerEventsTimeoutId) {\n        clearTimeout(this._disablePointerEventsTimeoutId);\n      }\n\n      this._disablePointerEventsTimeoutId = setTimeout(function () {\n        var isScrollingChange = _this2.props.isScrollingChange;\n        isScrollingChange(false);\n        _this2._disablePointerEventsTimeoutId = null;\n\n        _this2.setState({\n          isScrolling: false\n        });\n      }, IS_SCROLLING_TIMEOUT);\n    }\n  }, {\n    key: \"_invokeOnScrollMemoizer\",\n    value: function _invokeOnScrollMemoizer(_ref) {\n      var _this3 = this;\n\n      var scrollLeft = _ref.scrollLeft,\n          scrollTop = _ref.scrollTop,\n          totalHeight = _ref.totalHeight,\n          totalWidth = _ref.totalWidth;\n\n      this._onScrollMemoizer({\n        callback: function callback(_ref2) {\n          var scrollLeft = _ref2.scrollLeft,\n              scrollTop = _ref2.scrollTop;\n          var _this3$props = _this3.props,\n              height = _this3$props.height,\n              onScroll = _this3$props.onScroll,\n              width = _this3$props.width;\n          onScroll({\n            clientHeight: height,\n            clientWidth: width,\n            scrollHeight: totalHeight,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop,\n            scrollWidth: totalWidth\n          });\n        },\n        indices: {\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        }\n      });\n    }\n  }, {\n    key: \"_setScrollPosition\",\n    value: function _setScrollPosition(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n      var newState = {\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n      };\n\n      if (scrollLeft >= 0) {\n        newState.scrollLeft = scrollLeft;\n      }\n\n      if (scrollTop >= 0) {\n        newState.scrollTop = scrollTop;\n      }\n\n      if (scrollLeft >= 0 && scrollLeft !== this.state.scrollLeft || scrollTop >= 0 && scrollTop !== this.state.scrollTop) {\n        this.setState(newState);\n      }\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      if (nextProps.cellCount === 0 && (prevState.scrollLeft !== 0 || prevState.scrollTop !== 0)) {\n        return {\n          scrollLeft: 0,\n          scrollTop: 0,\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n        };\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft || nextProps.scrollTop !== prevState.scrollTop) {\n        return {\n          scrollLeft: nextProps.scrollLeft != null ? nextProps.scrollLeft : prevState.scrollLeft,\n          scrollTop: nextProps.scrollTop != null ? nextProps.scrollTop : prevState.scrollTop,\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  return CollectionView;\n}(React.PureComponent);\n\n_defineProperty(CollectionView, \"defaultProps\", {\n  'aria-label': 'grid',\n  horizontalOverscanSize: 0,\n  noContentRenderer: function noContentRenderer() {\n    return null;\n  },\n  onScroll: function onScroll() {\n    return null;\n  },\n  onSectionRendered: function onSectionRendered() {\n    return null;\n  },\n  scrollToAlignment: 'auto',\n  scrollToCell: -1,\n  style: {},\n  verticalOverscanSize: 0\n});\n\nCollectionView.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  'aria-label': PropTypes.string,\n\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height\n   * of rows can stretch the window. Intended for use with WindowScroller\n   */\n  autoHeight: PropTypes.bool,\n\n  /**\n   * Number of cells in collection.\n   */\n  cellCount: PropTypes.number.isRequired,\n\n  /**\n   * Calculates cell sizes and positions and manages rendering the appropriate cells given a specified window.\n   */\n  cellLayoutManager: PropTypes.object.isRequired,\n\n  /**\n   * Optional custom CSS class name to attach to root Collection element.\n   */\n  className: PropTypes.string,\n\n  /**\n   * Height of Collection; this property determines the number of visible (vs virtualized) rows.\n   */\n  height: PropTypes.number.isRequired,\n\n  /**\n   * Optional custom id to attach to root Collection element.\n   */\n  id: PropTypes.string,\n\n  /**\n   * Enables the `Collection` to horiontally \"overscan\" its content similar to how `Grid` does.\n   * This can reduce flicker around the edges when a user scrolls quickly.\n   */\n  horizontalOverscanSize: PropTypes.number.isRequired,\n  isScrollingChange: PropTypes.func,\n\n  /**\n   * Optional renderer to be used in place of rows when either :rowCount or :cellCount is 0.\n   */\n  noContentRenderer: PropTypes.func.isRequired,\n\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   * ({ clientHeight, clientWidth, scrollHeight, scrollLeft, scrollTop, scrollWidth }): void\n   */\n  onScroll: PropTypes.func.isRequired,\n\n  /**\n   * Callback invoked with information about the section of the Collection that was just rendered.\n   * This callback is passed a named :indices parameter which is an Array of the most recently rendered section indices.\n   */\n  onSectionRendered: PropTypes.func.isRequired,\n\n  /**\n   * Horizontal offset.\n   */\n  scrollLeft: PropTypes.number,\n\n  /**\n   * Controls scroll-to-cell behavior of the Grid.\n   * The default (\"auto\") scrolls the least amount possible to ensure that the specified cell is fully visible.\n   * Use \"start\" to align cells to the top/left of the Grid and \"end\" to align bottom/right.\n   */\n  scrollToAlignment: PropTypes.oneOf(['auto', 'end', 'start', 'center']).isRequired,\n\n  /**\n   * Cell index to ensure visible (by forcefully scrolling if necessary).\n   */\n  scrollToCell: PropTypes.number.isRequired,\n\n  /**\n   * Vertical offset.\n   */\n  scrollTop: PropTypes.number,\n\n  /**\n   * Optional custom inline style to attach to root Collection element.\n   */\n  style: PropTypes.object,\n\n  /**\n   * Enables the `Collection` to vertically \"overscan\" its content similar to how `Grid` does.\n   * This can reduce flicker around the edges when a user scrolls quickly.\n   */\n  verticalOverscanSize: PropTypes.number.isRequired,\n\n  /**\n   * Width of Collection; this property determines the number of visible (vs virtualized) columns.\n   */\n  width: PropTypes.number.isRequired\n} : {};\npolyfill(CollectionView);\nexport default CollectionView;","map":{"version":3,"sources":["/Users/jan/Documents/filen/app/node_modules/react-virtualized/dist/es/Collection/CollectionView.js"],"names":["_classCallCheck","_createClass","_possibleConstructorReturn","_getPrototypeOf","_assertThisInitialized","_inherits","_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","clsx","PropTypes","React","polyfill","createCallbackMemoizer","getScrollbarSize","IS_SCROLLING_TIMEOUT","SCROLL_POSITION_CHANGE_REASONS","OBSERVED","REQUESTED","CollectionView","_React$PureComponent","_getPrototypeOf2","_this","_len","args","Array","_key","call","concat","isScrolling","scrollLeft","scrollTop","_this$props","props","cellLayoutManager","onSectionRendered","_onSectionRenderedMemoizer","callback","indices","getLastRenderedIndices","ref","_scrollingContainer","_this$props2","height","scrollToAlignment","scrollToCell","width","_this$state","state","scrollPosition","getScrollPositionForCell","align","cellIndex","_setScrollPosition","event","_enablePointerEventsAfterDelay","_this$props3","isScrollingChange","scrollbarSize","_scrollbarSize","_cellLayoutManager$ge","getTotalSize","totalHeight","totalWidth","Math","max","min","scrollPositionChangeReason","cancelable","setState","_invokeOnScrollMemoizer","undefined","_scrollbarSizeMeasured","value","recomputeCellSizesAndPositions","_calculateSizeAndPositionDataOnNextUpdate","forceUpdate","componentDidMount","_this$props4","_updateScrollPositionForScrollToCell","_invokeOnSectionRenderedHelper","_cellLayoutManager$ge2","componentDidUpdate","prevProps","prevState","_this$props5","_this$state2","componentWillUnmount","_disablePointerEventsTimeoutId","clearTimeout","render","_this$props6","autoHeight","cellCount","className","horizontalOverscanSize","id","noContentRenderer","style","verticalOverscanSize","_this$state3","_lastRenderedCellCount","_lastRenderedCellLayoutManager","calculateSizeAndPositionData","_cellLayoutManager$ge3","left","top","right","bottom","childrenToDisplay","cellRenderers","x","y","collectionStyle","boxSizing","direction","position","WebkitOverflowScrolling","willChange","verticalScrollBarSize","horizontalScrollBarSize","overflowX","overflowY","createElement","_setScrollingContainerRef","onScroll","_onScroll","role","tabIndex","maxHeight","maxWidth","overflow","pointerEvents","_this2","setTimeout","_ref","_this3","_onScrollMemoizer","_ref2","_this3$props","clientHeight","clientWidth","scrollHeight","scrollWidth","_ref3","newState","getDerivedStateFromProps","nextProps","PureComponent","propTypes","process","env","NODE_ENV","string","bool","number","isRequired","func","oneOf"],"mappings":"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","sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport clsx from 'clsx';\nimport PropTypes from 'prop-types';\nimport * as React from 'react';\nimport { polyfill } from 'react-lifecycles-compat';\nimport createCallbackMemoizer from '../utils/createCallbackMemoizer';\nimport getScrollbarSize from 'dom-helpers/scrollbarSize'; // @TODO Merge Collection and CollectionView\n\n/**\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\n * This improves performance and makes scrolling smoother.\n */\n\nvar IS_SCROLLING_TIMEOUT = 150;\n/**\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\n */\n\nvar SCROLL_POSITION_CHANGE_REASONS = {\n  OBSERVED: 'observed',\n  REQUESTED: 'requested'\n};\n/**\n * Monitors changes in properties (eg. cellCount) and state (eg. scroll offsets) to determine when rendering needs to occur.\n * This component does not render any visible content itself; it defers to the specified :cellLayoutManager.\n */\n\nvar CollectionView =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(CollectionView, _React$PureComponent);\n\n  // Invokes callbacks only when their values have changed.\n  function CollectionView() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, CollectionView);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(CollectionView)).call.apply(_getPrototypeOf2, [this].concat(args))); // If this component is being rendered server-side, getScrollbarSize() will return undefined.\n    // We handle this case in componentDidMount()\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      isScrolling: false,\n      scrollLeft: 0,\n      scrollTop: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_calculateSizeAndPositionDataOnNextUpdate\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_onSectionRenderedMemoizer\", createCallbackMemoizer());\n\n    _defineProperty(_assertThisInitialized(_this), \"_onScrollMemoizer\", createCallbackMemoizer(false));\n\n    _defineProperty(_assertThisInitialized(_this), \"_invokeOnSectionRenderedHelper\", function () {\n      var _this$props = _this.props,\n          cellLayoutManager = _this$props.cellLayoutManager,\n          onSectionRendered = _this$props.onSectionRendered;\n\n      _this._onSectionRenderedMemoizer({\n        callback: onSectionRendered,\n        indices: {\n          indices: cellLayoutManager.getLastRenderedIndices()\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_setScrollingContainerRef\", function (ref) {\n      _this._scrollingContainer = ref;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_updateScrollPositionForScrollToCell\", function () {\n      var _this$props2 = _this.props,\n          cellLayoutManager = _this$props2.cellLayoutManager,\n          height = _this$props2.height,\n          scrollToAlignment = _this$props2.scrollToAlignment,\n          scrollToCell = _this$props2.scrollToCell,\n          width = _this$props2.width;\n      var _this$state = _this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n\n      if (scrollToCell >= 0) {\n        var scrollPosition = cellLayoutManager.getScrollPositionForCell({\n          align: scrollToAlignment,\n          cellIndex: scrollToCell,\n          height: height,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          width: width\n        });\n\n        if (scrollPosition.scrollLeft !== scrollLeft || scrollPosition.scrollTop !== scrollTop) {\n          _this._setScrollPosition(scrollPosition);\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_onScroll\", function (event) {\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\n      // See issue #404 for more information.\n      if (event.target !== _this._scrollingContainer) {\n        return;\n      } // Prevent pointer events from interrupting a smooth scroll\n\n\n      _this._enablePointerEventsAfterDelay(); // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\n      // This causes a series of rapid renders that is slow for long lists.\n      // We can avoid that by doing some simple bounds checking to ensure that scrollTop never exceeds the total height.\n\n\n      var _this$props3 = _this.props,\n          cellLayoutManager = _this$props3.cellLayoutManager,\n          height = _this$props3.height,\n          isScrollingChange = _this$props3.isScrollingChange,\n          width = _this$props3.width;\n      var scrollbarSize = _this._scrollbarSize;\n\n      var _cellLayoutManager$ge = cellLayoutManager.getTotalSize(),\n          totalHeight = _cellLayoutManager$ge.height,\n          totalWidth = _cellLayoutManager$ge.width;\n\n      var scrollLeft = Math.max(0, Math.min(totalWidth - width + scrollbarSize, event.target.scrollLeft));\n      var scrollTop = Math.max(0, Math.min(totalHeight - height + scrollbarSize, event.target.scrollTop)); // Certain devices (like Apple touchpad) rapid-fire duplicate events.\n      // Don't force a re-render if this is the case.\n      // The mouse may move faster then the animation frame does.\n      // Use requestAnimationFrame to avoid over-updating.\n\n      if (_this.state.scrollLeft !== scrollLeft || _this.state.scrollTop !== scrollTop) {\n        // Browsers with cancelable scroll events (eg. Firefox) interrupt scrolling animations if scrollTop/scrollLeft is set.\n        // Other browsers (eg. Safari) don't scroll as well without the help under certain conditions (DOM or style changes during scrolling).\n        // All things considered, this seems to be the best current work around that I'm aware of.\n        // For more information see https://github.com/bvaughn/react-virtualized/pull/124\n        var scrollPositionChangeReason = event.cancelable ? SCROLL_POSITION_CHANGE_REASONS.OBSERVED : SCROLL_POSITION_CHANGE_REASONS.REQUESTED; // Synchronously set :isScrolling the first time (since _setNextState will reschedule its animation frame each time it's called)\n\n        if (!_this.state.isScrolling) {\n          isScrollingChange(true);\n        }\n\n        _this.setState({\n          isScrolling: true,\n          scrollLeft: scrollLeft,\n          scrollPositionChangeReason: scrollPositionChangeReason,\n          scrollTop: scrollTop\n        });\n      }\n\n      _this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop,\n        totalWidth: totalWidth,\n        totalHeight: totalHeight\n      });\n    });\n\n    _this._scrollbarSize = getScrollbarSize();\n\n    if (_this._scrollbarSize === undefined) {\n      _this._scrollbarSizeMeasured = false;\n      _this._scrollbarSize = 0;\n    } else {\n      _this._scrollbarSizeMeasured = true;\n    }\n\n    return _this;\n  }\n  /**\n   * Forced recompute of cell sizes and positions.\n   * This function should be called if cell sizes have changed but nothing else has.\n   * Since cell positions are calculated by callbacks, the collection view has no way of detecting when the underlying data has changed.\n   */\n\n\n  _createClass(CollectionView, [{\n    key: \"recomputeCellSizesAndPositions\",\n    value: function recomputeCellSizesAndPositions() {\n      this._calculateSizeAndPositionDataOnNextUpdate = true;\n      this.forceUpdate();\n    }\n    /* ---------------------------- Component lifecycle methods ---------------------------- */\n\n    /**\n     * @private\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) Empty content (0 rows or columns)\n     * 2) New scroll props overriding the current state\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\n     */\n\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props4 = this.props,\n          cellLayoutManager = _this$props4.cellLayoutManager,\n          scrollLeft = _this$props4.scrollLeft,\n          scrollToCell = _this$props4.scrollToCell,\n          scrollTop = _this$props4.scrollTop; // If this component was first rendered server-side, scrollbar size will be undefined.\n      // In that event we need to remeasure.\n\n      if (!this._scrollbarSizeMeasured) {\n        this._scrollbarSize = getScrollbarSize();\n        this._scrollbarSizeMeasured = true;\n        this.setState({});\n      }\n\n      if (scrollToCell >= 0) {\n        this._updateScrollPositionForScrollToCell();\n      } else if (scrollLeft >= 0 || scrollTop >= 0) {\n        this._setScrollPosition({\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        });\n      } // Update onSectionRendered callback.\n\n\n      this._invokeOnSectionRenderedHelper();\n\n      var _cellLayoutManager$ge2 = cellLayoutManager.getTotalSize(),\n          totalHeight = _cellLayoutManager$ge2.height,\n          totalWidth = _cellLayoutManager$ge2.width; // Initialize onScroll callback.\n\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft || 0,\n        scrollTop: scrollTop || 0,\n        totalHeight: totalHeight,\n        totalWidth: totalWidth\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this$props5 = this.props,\n          height = _this$props5.height,\n          scrollToAlignment = _this$props5.scrollToAlignment,\n          scrollToCell = _this$props5.scrollToCell,\n          width = _this$props5.width;\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollPositionChangeReason = _this$state2.scrollPositionChangeReason,\n          scrollTop = _this$state2.scrollTop; // Make sure requested changes to :scrollLeft or :scrollTop get applied.\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\n      // So we only set these when we require an adjustment of the scroll position.\n      // See issue #2 for more information.\n\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\n        if (scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft && scrollLeft !== this._scrollingContainer.scrollLeft) {\n          this._scrollingContainer.scrollLeft = scrollLeft;\n        }\n\n        if (scrollTop >= 0 && scrollTop !== prevState.scrollTop && scrollTop !== this._scrollingContainer.scrollTop) {\n          this._scrollingContainer.scrollTop = scrollTop;\n        }\n      } // Update scroll offsets if the current :scrollToCell values requires it\n\n\n      if (height !== prevProps.height || scrollToAlignment !== prevProps.scrollToAlignment || scrollToCell !== prevProps.scrollToCell || width !== prevProps.width) {\n        this._updateScrollPositionForScrollToCell();\n      } // Update onRowsRendered callback if start/stop indices have changed\n\n\n      this._invokeOnSectionRenderedHelper();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this._disablePointerEventsTimeoutId) {\n        clearTimeout(this._disablePointerEventsTimeoutId);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props6 = this.props,\n          autoHeight = _this$props6.autoHeight,\n          cellCount = _this$props6.cellCount,\n          cellLayoutManager = _this$props6.cellLayoutManager,\n          className = _this$props6.className,\n          height = _this$props6.height,\n          horizontalOverscanSize = _this$props6.horizontalOverscanSize,\n          id = _this$props6.id,\n          noContentRenderer = _this$props6.noContentRenderer,\n          style = _this$props6.style,\n          verticalOverscanSize = _this$props6.verticalOverscanSize,\n          width = _this$props6.width;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollLeft = _this$state3.scrollLeft,\n          scrollTop = _this$state3.scrollTop; // Memoization reset\n\n      if (this._lastRenderedCellCount !== cellCount || this._lastRenderedCellLayoutManager !== cellLayoutManager || this._calculateSizeAndPositionDataOnNextUpdate) {\n        this._lastRenderedCellCount = cellCount;\n        this._lastRenderedCellLayoutManager = cellLayoutManager;\n        this._calculateSizeAndPositionDataOnNextUpdate = false;\n        cellLayoutManager.calculateSizeAndPositionData();\n      }\n\n      var _cellLayoutManager$ge3 = cellLayoutManager.getTotalSize(),\n          totalHeight = _cellLayoutManager$ge3.height,\n          totalWidth = _cellLayoutManager$ge3.width; // Safely expand the rendered area by the specified overscan amount\n\n\n      var left = Math.max(0, scrollLeft - horizontalOverscanSize);\n      var top = Math.max(0, scrollTop - verticalOverscanSize);\n      var right = Math.min(totalWidth, scrollLeft + width + horizontalOverscanSize);\n      var bottom = Math.min(totalHeight, scrollTop + height + verticalOverscanSize);\n      var childrenToDisplay = height > 0 && width > 0 ? cellLayoutManager.cellRenderers({\n        height: bottom - top,\n        isScrolling: isScrolling,\n        width: right - left,\n        x: left,\n        y: top\n      }) : [];\n      var collectionStyle = {\n        boxSizing: 'border-box',\n        direction: 'ltr',\n        height: autoHeight ? 'auto' : height,\n        position: 'relative',\n        WebkitOverflowScrolling: 'touch',\n        width: width,\n        willChange: 'transform'\n      }; // Force browser to hide scrollbars when we know they aren't necessary.\n      // Otherwise once scrollbars appear they may not disappear again.\n      // For more info see issue #116\n\n      var verticalScrollBarSize = totalHeight > height ? this._scrollbarSize : 0;\n      var horizontalScrollBarSize = totalWidth > width ? this._scrollbarSize : 0; // Also explicitly init styles to 'auto' if scrollbars are required.\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\n      // But an initial scroll index of offset is set as an external prop.\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\n\n      collectionStyle.overflowX = totalWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\n      collectionStyle.overflowY = totalHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\n      return React.createElement(\"div\", {\n        ref: this._setScrollingContainerRef,\n        \"aria-label\": this.props['aria-label'],\n        className: clsx('ReactVirtualized__Collection', className),\n        id: id,\n        onScroll: this._onScroll,\n        role: \"grid\",\n        style: _objectSpread({}, collectionStyle, {}, style),\n        tabIndex: 0\n      }, cellCount > 0 && React.createElement(\"div\", {\n        className: \"ReactVirtualized__Collection__innerScrollContainer\",\n        style: {\n          height: totalHeight,\n          maxHeight: totalHeight,\n          maxWidth: totalWidth,\n          overflow: 'hidden',\n          pointerEvents: isScrolling ? 'none' : '',\n          width: totalWidth\n        }\n      }, childrenToDisplay), cellCount === 0 && noContentRenderer());\n    }\n    /* ---------------------------- Helper methods ---------------------------- */\n\n    /**\n     * Sets an :isScrolling flag for a small window of time.\n     * This flag is used to disable pointer events on the scrollable portion of the Collection.\n     * This prevents jerky/stuttery mouse-wheel scrolling.\n     */\n\n  }, {\n    key: \"_enablePointerEventsAfterDelay\",\n    value: function _enablePointerEventsAfterDelay() {\n      var _this2 = this;\n\n      if (this._disablePointerEventsTimeoutId) {\n        clearTimeout(this._disablePointerEventsTimeoutId);\n      }\n\n      this._disablePointerEventsTimeoutId = setTimeout(function () {\n        var isScrollingChange = _this2.props.isScrollingChange;\n        isScrollingChange(false);\n        _this2._disablePointerEventsTimeoutId = null;\n\n        _this2.setState({\n          isScrolling: false\n        });\n      }, IS_SCROLLING_TIMEOUT);\n    }\n  }, {\n    key: \"_invokeOnScrollMemoizer\",\n    value: function _invokeOnScrollMemoizer(_ref) {\n      var _this3 = this;\n\n      var scrollLeft = _ref.scrollLeft,\n          scrollTop = _ref.scrollTop,\n          totalHeight = _ref.totalHeight,\n          totalWidth = _ref.totalWidth;\n\n      this._onScrollMemoizer({\n        callback: function callback(_ref2) {\n          var scrollLeft = _ref2.scrollLeft,\n              scrollTop = _ref2.scrollTop;\n          var _this3$props = _this3.props,\n              height = _this3$props.height,\n              onScroll = _this3$props.onScroll,\n              width = _this3$props.width;\n          onScroll({\n            clientHeight: height,\n            clientWidth: width,\n            scrollHeight: totalHeight,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop,\n            scrollWidth: totalWidth\n          });\n        },\n        indices: {\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        }\n      });\n    }\n  }, {\n    key: \"_setScrollPosition\",\n    value: function _setScrollPosition(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n      var newState = {\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n      };\n\n      if (scrollLeft >= 0) {\n        newState.scrollLeft = scrollLeft;\n      }\n\n      if (scrollTop >= 0) {\n        newState.scrollTop = scrollTop;\n      }\n\n      if (scrollLeft >= 0 && scrollLeft !== this.state.scrollLeft || scrollTop >= 0 && scrollTop !== this.state.scrollTop) {\n        this.setState(newState);\n      }\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      if (nextProps.cellCount === 0 && (prevState.scrollLeft !== 0 || prevState.scrollTop !== 0)) {\n        return {\n          scrollLeft: 0,\n          scrollTop: 0,\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n        };\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft || nextProps.scrollTop !== prevState.scrollTop) {\n        return {\n          scrollLeft: nextProps.scrollLeft != null ? nextProps.scrollLeft : prevState.scrollLeft,\n          scrollTop: nextProps.scrollTop != null ? nextProps.scrollTop : prevState.scrollTop,\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  return CollectionView;\n}(React.PureComponent);\n\n_defineProperty(CollectionView, \"defaultProps\", {\n  'aria-label': 'grid',\n  horizontalOverscanSize: 0,\n  noContentRenderer: function noContentRenderer() {\n    return null;\n  },\n  onScroll: function onScroll() {\n    return null;\n  },\n  onSectionRendered: function onSectionRendered() {\n    return null;\n  },\n  scrollToAlignment: 'auto',\n  scrollToCell: -1,\n  style: {},\n  verticalOverscanSize: 0\n});\n\nCollectionView.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  'aria-label': PropTypes.string,\n\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height\n   * of rows can stretch the window. Intended for use with WindowScroller\n   */\n  autoHeight: PropTypes.bool,\n\n  /**\n   * Number of cells in collection.\n   */\n  cellCount: PropTypes.number.isRequired,\n\n  /**\n   * Calculates cell sizes and positions and manages rendering the appropriate cells given a specified window.\n   */\n  cellLayoutManager: PropTypes.object.isRequired,\n\n  /**\n   * Optional custom CSS class name to attach to root Collection element.\n   */\n  className: PropTypes.string,\n\n  /**\n   * Height of Collection; this property determines the number of visible (vs virtualized) rows.\n   */\n  height: PropTypes.number.isRequired,\n\n  /**\n   * Optional custom id to attach to root Collection element.\n   */\n  id: PropTypes.string,\n\n  /**\n   * Enables the `Collection` to horiontally \"overscan\" its content similar to how `Grid` does.\n   * This can reduce flicker around the edges when a user scrolls quickly.\n   */\n  horizontalOverscanSize: PropTypes.number.isRequired,\n  isScrollingChange: PropTypes.func,\n\n  /**\n   * Optional renderer to be used in place of rows when either :rowCount or :cellCount is 0.\n   */\n  noContentRenderer: PropTypes.func.isRequired,\n\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   * ({ clientHeight, clientWidth, scrollHeight, scrollLeft, scrollTop, scrollWidth }): void\n   */\n  onScroll: PropTypes.func.isRequired,\n\n  /**\n   * Callback invoked with information about the section of the Collection that was just rendered.\n   * This callback is passed a named :indices parameter which is an Array of the most recently rendered section indices.\n   */\n  onSectionRendered: PropTypes.func.isRequired,\n\n  /**\n   * Horizontal offset.\n   */\n  scrollLeft: PropTypes.number,\n\n  /**\n   * Controls scroll-to-cell behavior of the Grid.\n   * The default (\"auto\") scrolls the least amount possible to ensure that the specified cell is fully visible.\n   * Use \"start\" to align cells to the top/left of the Grid and \"end\" to align bottom/right.\n   */\n  scrollToAlignment: PropTypes.oneOf(['auto', 'end', 'start', 'center']).isRequired,\n\n  /**\n   * Cell index to ensure visible (by forcefully scrolling if necessary).\n   */\n  scrollToCell: PropTypes.number.isRequired,\n\n  /**\n   * Vertical offset.\n   */\n  scrollTop: PropTypes.number,\n\n  /**\n   * Optional custom inline style to attach to root Collection element.\n   */\n  style: PropTypes.object,\n\n  /**\n   * Enables the `Collection` to vertically \"overscan\" its content similar to how `Grid` does.\n   * This can reduce flicker around the edges when a user scrolls quickly.\n   */\n  verticalOverscanSize: PropTypes.number.isRequired,\n\n  /**\n   * Width of Collection; this property determines the number of visible (vs virtualized) columns.\n   */\n  width: PropTypes.number.isRequired\n} : {};\npolyfill(CollectionView);\nexport default CollectionView;"]},"metadata":{},"sourceType":"module"}