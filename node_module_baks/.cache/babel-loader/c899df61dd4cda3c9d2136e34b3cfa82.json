{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n/**\n * Window Sections are used to group nearby cells.\n * This enables us to more quickly determine which cells to display in a given region of the Window.\n * \n */\n\nimport Section from './Section';\nvar SECTION_SIZE = 100;\n/**\n * Contains 0 to many Sections.\n * Grows (and adds Sections) dynamically as cells are registered.\n * Automatically adds cells to the appropriate Section(s).\n */\n\nvar SectionManager = /*#__PURE__*/function () {\n  function SectionManager() {\n    var sectionSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SECTION_SIZE;\n\n    _classCallCheck(this, SectionManager);\n\n    this._sectionSize = sectionSize;\n    this._cellMetadata = [];\n    this._sections = {};\n  }\n  /**\n   * Gets all cell indices contained in the specified region.\n   * A region may encompass 1 or more Sections.\n   */\n\n\n  _createClass(SectionManager, [{\n    key: \"getCellIndices\",\n    value: function getCellIndices(_ref) {\n      var height = _ref.height,\n          width = _ref.width,\n          x = _ref.x,\n          y = _ref.y;\n      var indices = {};\n      this.getSections({\n        height: height,\n        width: width,\n        x: x,\n        y: y\n      }).forEach(function (section) {\n        return section.getCellIndices().forEach(function (index) {\n          indices[index] = index;\n        });\n      }); // Object keys are strings; this function returns numbers\n\n      return Object.keys(indices).map(function (index) {\n        return indices[index];\n      });\n    }\n    /** Get size and position information for the cell specified. */\n\n  }, {\n    key: \"getCellMetadata\",\n    value: function getCellMetadata(_ref2) {\n      var index = _ref2.index;\n      return this._cellMetadata[index];\n    }\n    /** Get all Sections overlapping the specified region. */\n\n  }, {\n    key: \"getSections\",\n    value: function getSections(_ref3) {\n      var height = _ref3.height,\n          width = _ref3.width,\n          x = _ref3.x,\n          y = _ref3.y;\n      var sectionXStart = Math.floor(x / this._sectionSize);\n      var sectionXStop = Math.floor((x + width - 1) / this._sectionSize);\n      var sectionYStart = Math.floor(y / this._sectionSize);\n      var sectionYStop = Math.floor((y + height - 1) / this._sectionSize);\n      var sections = [];\n\n      for (var sectionX = sectionXStart; sectionX <= sectionXStop; sectionX++) {\n        for (var sectionY = sectionYStart; sectionY <= sectionYStop; sectionY++) {\n          var key = \"\".concat(sectionX, \".\").concat(sectionY);\n\n          if (!this._sections[key]) {\n            this._sections[key] = new Section({\n              height: this._sectionSize,\n              width: this._sectionSize,\n              x: sectionX * this._sectionSize,\n              y: sectionY * this._sectionSize\n            });\n          }\n\n          sections.push(this._sections[key]);\n        }\n      }\n\n      return sections;\n    }\n    /** Total number of Sections based on the currently registered cells. */\n\n  }, {\n    key: \"getTotalSectionCount\",\n    value: function getTotalSectionCount() {\n      return Object.keys(this._sections).length;\n    }\n    /** Intended for debugger/test purposes only */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var _this = this;\n\n      return Object.keys(this._sections).map(function (index) {\n        return _this._sections[index].toString();\n      });\n    }\n    /** Adds a cell to the appropriate Sections and registers it metadata for later retrievable. */\n\n  }, {\n    key: \"registerCell\",\n    value: function registerCell(_ref4) {\n      var cellMetadatum = _ref4.cellMetadatum,\n          index = _ref4.index;\n      this._cellMetadata[index] = cellMetadatum;\n      this.getSections(cellMetadatum).forEach(function (section) {\n        return section.addCellIndex({\n          index: index\n        });\n      });\n    }\n  }]);\n\n  return SectionManager;\n}();\n\nexport { SectionManager as default };\nimport { bpfrpt_proptype_Index } from \"./types\";\nimport { bpfrpt_proptype_SizeAndPositionInfo } from \"./types\";","map":{"version":3,"sources":["/Users/jan/Documents/filen/app/node_modules/react-virtualized/dist/es/Collection/SectionManager.js"],"names":["_classCallCheck","_createClass","Section","SECTION_SIZE","SectionManager","sectionSize","arguments","length","undefined","_sectionSize","_cellMetadata","_sections","key","value","getCellIndices","_ref","height","width","x","y","indices","getSections","forEach","section","index","Object","keys","map","getCellMetadata","_ref2","_ref3","sectionXStart","Math","floor","sectionXStop","sectionYStart","sectionYStop","sections","sectionX","sectionY","concat","push","getTotalSectionCount","toString","_this","registerCell","_ref4","cellMetadatum","addCellIndex","default","bpfrpt_proptype_Index","bpfrpt_proptype_SizeAndPositionInfo"],"mappings":"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","sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\n/**\n * Window Sections are used to group nearby cells.\n * This enables us to more quickly determine which cells to display in a given region of the Window.\n * \n */\nimport Section from './Section';\nvar SECTION_SIZE = 100;\n\n/**\n * Contains 0 to many Sections.\n * Grows (and adds Sections) dynamically as cells are registered.\n * Automatically adds cells to the appropriate Section(s).\n */\nvar SectionManager =\n/*#__PURE__*/\nfunction () {\n  function SectionManager() {\n    var sectionSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SECTION_SIZE;\n\n    _classCallCheck(this, SectionManager);\n\n    this._sectionSize = sectionSize;\n    this._cellMetadata = [];\n    this._sections = {};\n  }\n  /**\n   * Gets all cell indices contained in the specified region.\n   * A region may encompass 1 or more Sections.\n   */\n\n\n  _createClass(SectionManager, [{\n    key: \"getCellIndices\",\n    value: function getCellIndices(_ref) {\n      var height = _ref.height,\n          width = _ref.width,\n          x = _ref.x,\n          y = _ref.y;\n      var indices = {};\n      this.getSections({\n        height: height,\n        width: width,\n        x: x,\n        y: y\n      }).forEach(function (section) {\n        return section.getCellIndices().forEach(function (index) {\n          indices[index] = index;\n        });\n      }); // Object keys are strings; this function returns numbers\n\n      return Object.keys(indices).map(function (index) {\n        return indices[index];\n      });\n    }\n    /** Get size and position information for the cell specified. */\n\n  }, {\n    key: \"getCellMetadata\",\n    value: function getCellMetadata(_ref2) {\n      var index = _ref2.index;\n      return this._cellMetadata[index];\n    }\n    /** Get all Sections overlapping the specified region. */\n\n  }, {\n    key: \"getSections\",\n    value: function getSections(_ref3) {\n      var height = _ref3.height,\n          width = _ref3.width,\n          x = _ref3.x,\n          y = _ref3.y;\n      var sectionXStart = Math.floor(x / this._sectionSize);\n      var sectionXStop = Math.floor((x + width - 1) / this._sectionSize);\n      var sectionYStart = Math.floor(y / this._sectionSize);\n      var sectionYStop = Math.floor((y + height - 1) / this._sectionSize);\n      var sections = [];\n\n      for (var sectionX = sectionXStart; sectionX <= sectionXStop; sectionX++) {\n        for (var sectionY = sectionYStart; sectionY <= sectionYStop; sectionY++) {\n          var key = \"\".concat(sectionX, \".\").concat(sectionY);\n\n          if (!this._sections[key]) {\n            this._sections[key] = new Section({\n              height: this._sectionSize,\n              width: this._sectionSize,\n              x: sectionX * this._sectionSize,\n              y: sectionY * this._sectionSize\n            });\n          }\n\n          sections.push(this._sections[key]);\n        }\n      }\n\n      return sections;\n    }\n    /** Total number of Sections based on the currently registered cells. */\n\n  }, {\n    key: \"getTotalSectionCount\",\n    value: function getTotalSectionCount() {\n      return Object.keys(this._sections).length;\n    }\n    /** Intended for debugger/test purposes only */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var _this = this;\n\n      return Object.keys(this._sections).map(function (index) {\n        return _this._sections[index].toString();\n      });\n    }\n    /** Adds a cell to the appropriate Sections and registers it metadata for later retrievable. */\n\n  }, {\n    key: \"registerCell\",\n    value: function registerCell(_ref4) {\n      var cellMetadatum = _ref4.cellMetadatum,\n          index = _ref4.index;\n      this._cellMetadata[index] = cellMetadatum;\n      this.getSections(cellMetadatum).forEach(function (section) {\n        return section.addCellIndex({\n          index: index\n        });\n      });\n    }\n  }]);\n\n  return SectionManager;\n}();\n\nexport { SectionManager as default };\nimport { bpfrpt_proptype_Index } from \"./types\";\nimport { bpfrpt_proptype_SizeAndPositionInfo } from \"./types\";"]},"metadata":{},"sourceType":"module"}